"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionCrypto = void 0;
const utils_1 = require("../utils");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
if ((0, utils_1.isNode)()) {
    try {
        eval("global.crypto = require('crypto').webcrypto");
    }
    catch (err) { }
}
class SessionCrypto {
    constructor(keyPair) {
        this.nonceLength = 24;
        this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
        this.sessionId = (0, utils_1.toHexString)(this.keyPair.publicKey);
    }
    createKeypair() {
        return tweetnacl_1.default.box.keyPair();
    }
    createKeypairFromString(keyPair) {
        return {
            publicKey: (0, utils_1.hexToByteArray)(keyPair.publicKey),
            secretKey: (0, utils_1.hexToByteArray)(keyPair.secretKey)
        };
    }
    createNonce() {
        const buffer = new Uint8Array(this.nonceLength);
        return crypto.getRandomValues(buffer);
    }
    encrypt(message, receiverPublicKey) {
        const encodedMessage = new TextEncoder().encode(message);
        const nonce = this.createNonce();
        const encrypted = tweetnacl_1.default.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
        return (0, utils_1.concatUint8Arrays)(nonce, encrypted);
    }
    decrypt(message, senderPublicKey) {
        const [nonce, internalMessage] = (0, utils_1.splitToUint8Arrays)(message, this.nonceLength);
        const decrypted = tweetnacl_1.default.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
        if (!decrypted) {
            throw new Error(`Decryption error: \n message: ${message.toString()} \n sender pubkey: ${senderPublicKey.toString()} \n keypair pubkey: ${this.keyPair.publicKey.toString()} \n keypair secretkey: ${this.keyPair.secretKey.toString()}`);
        }
        return new TextDecoder().decode(decrypted);
    }
    stringifyKeypair() {
        return {
            publicKey: (0, utils_1.toHexString)(this.keyPair.publicKey),
            secretKey: (0, utils_1.toHexString)(this.keyPair.secretKey)
        };
    }
}
exports.SessionCrypto = SessionCrypto;
//# sourceMappingURL=session-crypto.js.map