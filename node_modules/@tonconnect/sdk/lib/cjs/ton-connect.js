"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonConnect = void 0;
const dapp_metadata_error_1 = require("./errors/dapp/dapp-metadata.error");
const manifest_content_error_error_1 = require("./errors/protocol/events/connect/manifest-content-error.error");
const manifest_not_found_error_1 = require("./errors/protocol/events/connect/manifest-not-found.error");
const ton_connect_error_1 = require("./errors/ton-connect.error");
const wallet_already_connected_error_1 = require("./errors/wallet/wallet-already-connected.error");
const wallet_not_connected_error_1 = require("./errors/wallet/wallet-not-connected.error");
const wallet_not_support_feature_error_1 = require("./errors/wallet/wallet-not-support-feature.error");
const wallet_connection_source_1 = require("./models/wallet/wallet-connection-source");
const connect_errors_parser_1 = require("./parsers/connect-errors-parser");
const send_transaction_parser_1 = require("./parsers/send-transaction-parser");
const bridge_provider_1 = require("./provider/bridge/bridge-provider");
const injected_provider_1 = require("./provider/injected/injected-provider");
const bridge_connection_storage_1 = require("./storage/bridge-connection-storage");
const default_storage_1 = require("./storage/default-storage");
const web_api_1 = require("./utils/web-api");
const wallets_list_manager_1 = require("./wallets-list-manager");
class TonConnect {
    constructor(options) {
        this.walletsList = new wallets_list_manager_1.WalletsListManager();
        this._wallet = null;
        this.provider = null;
        this.statusChangeSubscriptions = [];
        this.statusChangeErrorSubscriptions = [];
        this.dappSettings = {
            manifestUrl: (options === null || options === void 0 ? void 0 : options.manifestUrl) || (0, web_api_1.getWebPageManifest)(),
            storage: (options === null || options === void 0 ? void 0 : options.storage) || new default_storage_1.DefaultStorage()
        };
        this.walletsList = new wallets_list_manager_1.WalletsListManager(options === null || options === void 0 ? void 0 : options.walletsListSource);
        if (!this.dappSettings.manifestUrl) {
            throw new dapp_metadata_error_1.DappMetadataError('Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest');
        }
        this.bridgeConnectionStorage = new bridge_connection_storage_1.BridgeConnectionStorage(this.dappSettings.storage);
    }
    /**
     * Returns available wallets list.
     */
    static getWallets() {
        return this.walletsList.getWallets();
    }
    /**
     * Shows if the wallet is connected right now.
     */
    get connected() {
        return this._wallet !== null;
    }
    /**
     * Current connected account or null if no account is connected.
     */
    get account() {
        var _a;
        return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;
    }
    /**
     * Current connected wallet or null if no account is connected.
     */
    get wallet() {
        return this._wallet;
    }
    set wallet(value) {
        this._wallet = value;
        this.statusChangeSubscriptions.forEach(callback => callback(this._wallet));
    }
    /**
     * Returns available wallets list.
     */
    getWallets() {
        return this.walletsList.getWallets();
    }
    /**
     * Allows to subscribe to connection status changes and handle connection errors.
     * @param callback will be called after connections status changes with actual wallet or null.
     * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.
     * @returns unsubscribe callback.
     */
    onStatusChange(callback, errorsHandler) {
        this.statusChangeSubscriptions.push(callback);
        if (errorsHandler) {
            this.statusChangeErrorSubscriptions.push(errorsHandler);
        }
        return () => {
            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(item => item !== callback);
            if (errorsHandler) {
                this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(item => item !== errorsHandler);
            }
        };
    }
    connect(wallet, request) {
        var _a;
        if (this.connected) {
            throw new wallet_already_connected_error_1.WalletAlreadyConnectedError();
        }
        (_a = this.provider) === null || _a === void 0 ? void 0 : _a.closeConnection();
        this.provider = this.createProvider(wallet);
        return this.provider.connect(this.createConnectRequest(request));
    }
    /**
     * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.
     */
    restoreConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            const [bridgeConnectionType, embeddedWallet] = yield Promise.all([
                this.bridgeConnectionStorage.storedConnectionType(),
                this.walletsList.getEmbeddedWallet()
            ]);
            switch (bridgeConnectionType) {
                case 'http':
                    this.provider = yield bridge_provider_1.BridgeProvider.fromStorage(this.dappSettings.storage);
                    break;
                case 'injected':
                    this.provider = yield injected_provider_1.InjectedProvider.fromStorage(this.dappSettings.storage);
                    break;
                default:
                    if (embeddedWallet) {
                        this.provider = yield this.createProvider(embeddedWallet);
                    }
                    else {
                        return;
                    }
            }
            this.provider.listen(this.walletEventsListener.bind(this));
            return this.provider.restoreConnection();
        });
    }
    /**
     * Asks connected wallet to sign and send the transaction.
     * @param transaction transaction to send.
     * @returns signed transaction boc that allows you to find the transaction in the blockchain.
     * If user rejects transaction, method will throw the corresponding error.
     */
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkConnection();
            this.checkFeatureSupport('SendTransaction');
            const { validUntil } = transaction, tx = __rest(transaction, ["validUntil"]);
            const response = yield this.provider.sendRequest(send_transaction_parser_1.sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), { valid_until: validUntil })));
            if (send_transaction_parser_1.sendTransactionParser.isError(response)) {
                return send_transaction_parser_1.sendTransactionParser.parseAndThrowError(response);
            }
            return send_transaction_parser_1.sendTransactionParser.convertFromRpcResponse(response);
        });
    }
    /**
     * Disconnect form thw connected wallet and drop current session.
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connected) {
                throw new wallet_not_connected_error_1.WalletNotConnectedError();
            }
            yield this.provider.disconnect();
            this.onWalletDisconnected();
        });
    }
    createProvider(wallet) {
        let provider;
        if ((0, wallet_connection_source_1.isWalletConnectionSourceJS)(wallet)) {
            provider = new injected_provider_1.InjectedProvider(this.dappSettings.storage, wallet.jsBridgeKey);
        }
        else {
            provider = new bridge_provider_1.BridgeProvider(this.dappSettings.storage, wallet);
        }
        provider.listen(this.walletEventsListener.bind(this));
        return provider;
    }
    walletEventsListener(e) {
        switch (e.event) {
            case 'connect':
                this.onWalletConnected(e.payload);
                break;
            case 'connect_error':
                this.onWalletConnectError(e.payload);
                break;
            case 'disconnect':
                this.onWalletDisconnected();
        }
    }
    onWalletConnected(connectEvent) {
        const tonAccountItem = connectEvent.items.find(item => item.name === 'ton_addr');
        const tonProofItem = connectEvent.items.find(item => item.name === 'ton_proof');
        if (!tonAccountItem) {
            throw new ton_connect_error_1.TonConnectError('ton_addr connection item was not found');
        }
        const wallet = {
            device: connectEvent.device,
            provider: this.provider.type,
            account: {
                address: tonAccountItem.address,
                chain: tonAccountItem.network,
                walletStateInit: tonAccountItem.walletStateInit
            }
        };
        if (tonProofItem) {
            wallet.connectItems = {
                tonProof: tonProofItem
            };
        }
        this.wallet = wallet;
    }
    onWalletConnectError(connectEventError) {
        const error = connect_errors_parser_1.connectErrorsParser.parseError(connectEventError);
        this.statusChangeErrorSubscriptions.forEach(errorsHandler => errorsHandler(error));
        console.debug(error);
        if (error instanceof manifest_not_found_error_1.ManifestNotFoundError || error instanceof manifest_content_error_error_1.ManifestContentErrorError) {
            console.error(error);
            throw error;
        }
    }
    onWalletDisconnected() {
        this.wallet = null;
    }
    checkConnection() {
        if (!this.connected) {
            throw new wallet_not_connected_error_1.WalletNotConnectedError();
        }
    }
    checkFeatureSupport(feature) {
        var _a;
        if (!((_a = this.wallet) === null || _a === void 0 ? void 0 : _a.device.features.includes(feature))) {
            throw new wallet_not_support_feature_error_1.WalletNotSupportFeatureError();
        }
    }
    createConnectRequest(request) {
        const items = [
            {
                name: 'ton_addr'
            }
        ];
        if (request === null || request === void 0 ? void 0 : request.tonProof) {
            items.push({
                name: 'ton_proof',
                payload: request.tonProof
            });
        }
        return {
            manifestUrl: this.dappSettings.manifestUrl,
            items
        };
    }
}
exports.TonConnect = TonConnect;
TonConnect.walletsList = new wallets_list_manager_1.WalletsListManager();
/**
 * Check if specified wallet is injected and available to use with the app.
 * @param walletJSKey target wallet's js bridge key.
 */
TonConnect.isWalletInjected = (walletJSKey) => injected_provider_1.InjectedProvider.isWalletInjected(walletJSKey);
/**
 * Check if the app is opened inside specified wallet's browser.
 * @param walletJSKey target wallet's js bridge key.
 */
TonConnect.isInsideWalletBrowser = (walletJSKey) => injected_provider_1.InjectedProvider.isInsideWalletBrowser(walletJSKey);
//# sourceMappingURL=ton-connect.js.map