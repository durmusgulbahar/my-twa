import {
  require_dist,
  require_dist2
} from "./chunk-VBLUMNAS.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  import_buffer,
  import_process,
  init_shim
} from "./chunk-EZYI2BHV.js";

// node_modules/fp-ts/es6/function.js
function identity(a) {
  return a;
}
function constant(a) {
  return function() {
    return a;
  };
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var constTrue, constFalse, constNull, constUndefined, SK;
var init_function = __esm({
  "node_modules/fp-ts/es6/function.js"() {
    init_shim();
    constTrue = constant(true);
    constFalse = constant(false);
    constNull = constant(null);
    constUndefined = constant(void 0);
    SK = function(_, b) {
      return b;
    };
  }
});

// node_modules/fp-ts/es6/internal.js
var __spreadArray, isNone, isSome, none, some, isLeft, isRight, left, right, singleton, isNonEmpty, head, tail, emptyReadonlyArray, emptyRecord, has, fromReadonlyNonEmptyArray;
var init_internal = __esm({
  "node_modules/fp-ts/es6/internal.js"() {
    init_shim();
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isNone = function(fa) {
      return fa._tag === "None";
    };
    isSome = function(fa) {
      return fa._tag === "Some";
    };
    none = { _tag: "None" };
    some = function(a) {
      return { _tag: "Some", value: a };
    };
    isLeft = function(ma) {
      return ma._tag === "Left";
    };
    isRight = function(ma) {
      return ma._tag === "Right";
    };
    left = function(e) {
      return { _tag: "Left", left: e };
    };
    right = function(a) {
      return { _tag: "Right", right: a };
    };
    singleton = function(a) {
      return [a];
    };
    isNonEmpty = function(as) {
      return as.length > 0;
    };
    head = function(as) {
      return as[0];
    };
    tail = function(as) {
      return as.slice(1);
    };
    emptyReadonlyArray = [];
    emptyRecord = {};
    has = Object.prototype.hasOwnProperty;
    fromReadonlyNonEmptyArray = function(as) {
      return __spreadArray([as[0]], as.slice(1), true);
    };
  }
});

// node_modules/fp-ts/es6/Apply.js
function apFirst(A) {
  return function(second) {
    return function(first2) {
      return A.ap(A.map(first2, function(a) {
        return function() {
          return a;
        };
      }), second);
    };
  };
}
function apSecond(A) {
  return function(second) {
    return function(first2) {
      return A.ap(A.map(first2, function() {
        return function(b) {
          return b;
        };
      }), second);
    };
  };
}
function apS(F) {
  return function(name, fb) {
    return function(fa) {
      return F.ap(F.map(fa, function(a) {
        return function(b) {
          var _a;
          return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        };
      }), fb);
    };
  };
}
function getApplySemigroup(F) {
  return function(S) {
    return {
      concat: function(first2, second) {
        return F.ap(F.map(first2, function(x) {
          return function(y) {
            return S.concat(x, y);
          };
        }), second);
      }
    };
  };
}
var init_Apply = __esm({
  "node_modules/fp-ts/es6/Apply.js"() {
    init_shim();
    init_function();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Functor.js
function flap(F) {
  return function(a) {
    return function(fab) {
      return F.map(fab, function(f) {
        return f(a);
      });
    };
  };
}
function bindTo(F) {
  return function(name) {
    return function(fa) {
      return F.map(fa, function(a) {
        var _a;
        return _a = {}, _a[name] = a, _a;
      });
    };
  };
}
function let_(F) {
  return function(name, f) {
    return function(fa) {
      return F.map(fa, function(a) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
      });
    };
  };
}
var init_Functor = __esm({
  "node_modules/fp-ts/es6/Functor.js"() {
    init_shim();
    init_function();
  }
});

// node_modules/fp-ts/es6/Applicative.js
function getApplicativeMonoid(F) {
  var f = getApplySemigroup(F);
  return function(M) {
    return {
      concat: f(M).concat,
      empty: F.of(M.empty)
    };
  };
}
var init_Applicative = __esm({
  "node_modules/fp-ts/es6/Applicative.js"() {
    init_shim();
    init_Apply();
    init_function();
    init_Functor();
  }
});

// node_modules/fp-ts/es6/Chain.js
function chainFirst(M) {
  return function(f) {
    return function(first2) {
      return M.chain(first2, function(a) {
        return M.map(f(a), function() {
          return a;
        });
      });
    };
  };
}
function bind(M) {
  return function(name, f) {
    return function(ma) {
      return M.chain(ma, function(a) {
        return M.map(f(a), function(b) {
          var _a;
          return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        });
      });
    };
  };
}
var init_Chain = __esm({
  "node_modules/fp-ts/es6/Chain.js"() {
    init_shim();
  }
});

// node_modules/fp-ts/es6/ChainRec.js
var tailRec;
var init_ChainRec = __esm({
  "node_modules/fp-ts/es6/ChainRec.js"() {
    init_shim();
    tailRec = function(startWith, f) {
      var ab = f(startWith);
      while (ab._tag === "Left") {
        ab = f(ab.left);
      }
      return ab.right;
    };
  }
});

// node_modules/fp-ts/es6/FromEither.js
function fromOption(F) {
  return function(onNone) {
    return function(ma) {
      return F.fromEither(isNone(ma) ? left(onNone()) : right(ma.value));
    };
  };
}
function fromPredicate(F) {
  return function(predicate, onFalse) {
    return function(a) {
      return F.fromEither(predicate(a) ? right(a) : left(onFalse(a)));
    };
  };
}
function fromOptionK(F) {
  var fromOptionF = fromOption(F);
  return function(onNone) {
    var from = fromOptionF(onNone);
    return function(f) {
      return flow(f, from);
    };
  };
}
function chainOptionK(F, M) {
  var fromOptionKF = fromOptionK(F);
  return function(onNone) {
    var from = fromOptionKF(onNone);
    return function(f) {
      return function(ma) {
        return M.chain(ma, from(f));
      };
    };
  };
}
function fromEitherK(F) {
  return function(f) {
    return flow(f, F.fromEither);
  };
}
function chainEitherK(F, M) {
  var fromEitherKF = fromEitherK(F);
  return function(f) {
    return function(ma) {
      return M.chain(ma, fromEitherKF(f));
    };
  };
}
function chainFirstEitherK(F, M) {
  return flow(fromEitherK(F), chainFirst(M));
}
function filterOrElse(F, M) {
  return function(predicate, onFalse) {
    return function(ma) {
      return M.chain(ma, function(a) {
        return F.fromEither(predicate(a) ? right(a) : left(onFalse(a)));
      });
    };
  };
}
var init_FromEither = __esm({
  "node_modules/fp-ts/es6/FromEither.js"() {
    init_shim();
    init_Chain();
    init_function();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Separated.js
var separated, _map, map, URI, Functor, flap2, left2, right2;
var init_Separated = __esm({
  "node_modules/fp-ts/es6/Separated.js"() {
    init_shim();
    init_function();
    init_Functor();
    separated = function(left4, right4) {
      return { left: left4, right: right4 };
    };
    _map = function(fa, f) {
      return pipe(fa, map(f));
    };
    map = function(f) {
      return function(fa) {
        return separated(left2(fa), f(right2(fa)));
      };
    };
    URI = "Separated";
    Functor = {
      URI,
      map: _map
    };
    flap2 = flap(Functor);
    left2 = function(s) {
      return s.left;
    };
    right2 = function(s) {
      return s.right;
    };
  }
});

// node_modules/fp-ts/es6/Witherable.js
function wiltDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f) {
      return F.map(traverseF(wa, f), C.separate);
    };
  };
}
function witherDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f) {
      return F.map(traverseF(wa, f), C.compact);
    };
  };
}
function filterE(W) {
  return function(F) {
    var witherF = W.wither(F);
    return function(predicate) {
      return function(ga) {
        return witherF(ga, function(a) {
          return F.map(predicate(a), function(b) {
            return b ? some(a) : none;
          });
        });
      };
    };
  };
}
var init_Witherable = __esm({
  "node_modules/fp-ts/es6/Witherable.js"() {
    init_shim();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Either.js
var Either_exports = {};
__export(Either_exports, {
  Alt: () => Alt,
  ApT: () => ApT,
  Applicative: () => Applicative,
  Apply: () => Apply,
  Bifunctor: () => Bifunctor,
  Chain: () => Chain,
  ChainRec: () => ChainRec,
  Do: () => Do,
  Extend: () => Extend,
  Foldable: () => Foldable,
  FromEither: () => FromEither,
  Functor: () => Functor2,
  Monad: () => Monad,
  MonadThrow: () => MonadThrow,
  Pointed: () => Pointed,
  Traversable: () => Traversable,
  URI: () => URI2,
  alt: () => alt,
  altW: () => altW,
  ap: () => ap2,
  apFirst: () => apFirst2,
  apFirstW: () => apFirstW,
  apS: () => apS2,
  apSW: () => apSW,
  apSecond: () => apSecond2,
  apSecondW: () => apSecondW,
  apW: () => apW,
  bimap: () => bimap,
  bind: () => bind2,
  bindTo: () => bindTo2,
  bindW: () => bindW,
  chain: () => chain,
  chainFirst: () => chainFirst2,
  chainFirstW: () => chainFirstW,
  chainNullableK: () => chainNullableK,
  chainOptionK: () => chainOptionK2,
  chainW: () => chainW,
  duplicate: () => duplicate,
  either: () => either,
  elem: () => elem,
  exists: () => exists,
  extend: () => extend,
  filterOrElse: () => filterOrElse2,
  filterOrElseW: () => filterOrElseW,
  flap: () => flap3,
  flatten: () => flatten,
  flattenW: () => flattenW,
  fold: () => fold,
  foldMap: () => foldMap,
  foldW: () => foldW,
  fromNullable: () => fromNullable,
  fromNullableK: () => fromNullableK,
  fromOption: () => fromOption2,
  fromOptionK: () => fromOptionK2,
  fromPredicate: () => fromPredicate2,
  getAltValidation: () => getAltValidation,
  getApplicativeValidation: () => getApplicativeValidation,
  getApplyMonoid: () => getApplyMonoid,
  getApplySemigroup: () => getApplySemigroup2,
  getCompactable: () => getCompactable,
  getEq: () => getEq,
  getFilterable: () => getFilterable,
  getOrElse: () => getOrElse,
  getOrElseW: () => getOrElseW,
  getSemigroup: () => getSemigroup,
  getShow: () => getShow,
  getValidation: () => getValidation,
  getValidationMonoid: () => getValidationMonoid,
  getValidationSemigroup: () => getValidationSemigroup,
  getWitherable: () => getWitherable,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left3,
  let: () => let_2,
  map: () => map2,
  mapLeft: () => mapLeft,
  match: () => match,
  matchW: () => matchW,
  of: () => of,
  orElse: () => orElse,
  orElseW: () => orElseW,
  parseJSON: () => parseJSON,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  right: () => right3,
  sequence: () => sequence,
  sequenceArray: () => sequenceArray,
  stringifyJSON: () => stringifyJSON,
  swap: () => swap,
  throwError: () => throwError,
  toError: () => toError,
  toUnion: () => toUnion,
  traverse: () => traverse,
  traverseArray: () => traverseArray,
  traverseArrayWithIndex: () => traverseArrayWithIndex,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex,
  tryCatch: () => tryCatch,
  tryCatchK: () => tryCatchK
});
function toError(e) {
  return e instanceof Error ? e : new Error(String(e));
}
function elem(E) {
  return function(a, ma) {
    if (ma === void 0) {
      var elemE_1 = elem(E);
      return function(ma2) {
        return elemE_1(a, ma2);
      };
    }
    return isLeft2(ma) ? false : E.equals(a, ma.right);
  };
}
function parseJSON(s, onError) {
  return tryCatch(function() {
    return JSON.parse(s);
  }, onError);
}
function getValidation(SE) {
  var ap9 = getApplicativeValidation(SE).ap;
  var alt6 = getAltValidation(SE).alt;
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    of,
    chain: _chain,
    bimap: _bimap,
    mapLeft: _mapLeft,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    extend: _extend,
    traverse: _traverse,
    sequence,
    chainRec: _chainRec,
    throwError,
    ap: ap9,
    alt: alt6
  };
}
var left3, right3, _map2, _ap, _chain, _reduce, _foldMap, _reduceRight, _traverse, _bimap, _mapLeft, _alt, _extend, _chainRec, URI2, getShow, getEq, getSemigroup, getCompactable, getFilterable, getWitherable, getApplicativeValidation, getAltValidation, map2, Functor2, of, Pointed, apW, ap2, Apply, Applicative, chainW, chain, Chain, Monad, reduce, foldMap, reduceRight, Foldable, traverse, sequence, Traversable, bimap, mapLeft, Bifunctor, altW, alt, Alt, extend, Extend, ChainRec, throwError, MonadThrow, FromEither, fromPredicate2, fromOption2, isLeft2, isRight2, matchW, foldW, match, fold, getOrElseW, getOrElse, flap3, apFirst2, apFirstW, apSecond2, apSecondW, chainFirst2, chainFirstW, flattenW, flatten, duplicate, fromOptionK2, chainOptionK2, filterOrElse2, filterOrElseW, swap, orElseW, orElse, fromNullable, tryCatch, tryCatchK, fromNullableK, chainNullableK, toUnion, exists, Do, bindTo2, let_2, bind2, bindW, apS2, apSW, ApT, traverseReadonlyNonEmptyArrayWithIndex, traverseReadonlyArrayWithIndex, traverseArrayWithIndex, traverseArray, sequenceArray, stringifyJSON, either, getApplySemigroup2, getApplyMonoid, getValidationSemigroup, getValidationMonoid;
var init_Either = __esm({
  "node_modules/fp-ts/es6/Either.js"() {
    init_shim();
    init_Applicative();
    init_Apply();
    init_Chain();
    init_ChainRec();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_Separated();
    init_Witherable();
    left3 = left;
    right3 = right;
    _map2 = function(fa, f) {
      return pipe(fa, map2(f));
    };
    _ap = function(fab, fa) {
      return pipe(fab, ap2(fa));
    };
    _chain = function(ma, f) {
      return pipe(ma, chain(f));
    };
    _reduce = function(fa, b, f) {
      return pipe(fa, reduce(b, f));
    };
    _foldMap = function(M) {
      return function(fa, f) {
        var foldMapM = foldMap(M);
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight = function(fa, b, f) {
      return pipe(fa, reduceRight(b, f));
    };
    _traverse = function(F) {
      var traverseF = traverse(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _bimap = function(fa, f, g) {
      return pipe(fa, bimap(f, g));
    };
    _mapLeft = function(fa, f) {
      return pipe(fa, mapLeft(f));
    };
    _alt = function(fa, that) {
      return pipe(fa, alt(that));
    };
    _extend = function(wa, f) {
      return pipe(wa, extend(f));
    };
    _chainRec = function(a, f) {
      return tailRec(f(a), function(e) {
        return isLeft2(e) ? right3(left3(e.left)) : isLeft2(e.right) ? left3(f(e.right.left)) : right3(right3(e.right.right));
      });
    };
    URI2 = "Either";
    getShow = function(SE, SA) {
      return {
        show: function(ma) {
          return isLeft2(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    getEq = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || (isLeft2(x) ? isLeft2(y) && EL.equals(x.left, y.left) : isRight2(y) && EA.equals(x.right, y.right));
        }
      };
    };
    getSemigroup = function(S) {
      return {
        concat: function(x, y) {
          return isLeft2(y) ? x : isLeft2(x) ? y : right3(S.concat(x.right, y.right));
        }
      };
    };
    getCompactable = function(M) {
      var empty7 = left3(M.empty);
      return {
        URI: URI2,
        _E: void 0,
        compact: function(ma) {
          return isLeft2(ma) ? ma : ma.right._tag === "None" ? empty7 : right3(ma.right.value);
        },
        separate: function(ma) {
          return isLeft2(ma) ? separated(ma, ma) : isLeft2(ma.right) ? separated(right3(ma.right.left), empty7) : separated(empty7, right3(ma.right.right));
        }
      };
    };
    getFilterable = function(M) {
      var empty7 = left3(M.empty);
      var _a = getCompactable(M), compact6 = _a.compact, separate6 = _a.separate;
      var filter8 = function(ma, predicate) {
        return isLeft2(ma) ? ma : predicate(ma.right) ? ma : empty7;
      };
      var partition7 = function(ma, p) {
        return isLeft2(ma) ? separated(ma, ma) : p(ma.right) ? separated(empty7, right3(ma.right)) : separated(right3(ma.right), empty7);
      };
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        compact: compact6,
        separate: separate6,
        filter: filter8,
        filterMap: function(ma, f) {
          if (isLeft2(ma)) {
            return ma;
          }
          var ob = f(ma.right);
          return ob._tag === "None" ? empty7 : right3(ob.value);
        },
        partition: partition7,
        partitionMap: function(ma, f) {
          if (isLeft2(ma)) {
            return separated(ma, ma);
          }
          var e = f(ma.right);
          return isLeft2(e) ? separated(right3(e.left), empty7) : separated(empty7, right3(e.right));
        }
      };
    };
    getWitherable = function(M) {
      var F_ = getFilterable(M);
      var C = getCompactable(M);
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse,
        sequence,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        wither: witherDefault(Traversable, C),
        wilt: wiltDefault(Traversable, C)
      };
    };
    getApplicativeValidation = function(SE) {
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return isLeft2(fab) ? isLeft2(fa) ? left3(SE.concat(fab.left, fa.left)) : fab : isLeft2(fa) ? fa : right3(fab.right(fa.right));
        },
        of
      };
    };
    getAltValidation = function(SE) {
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        alt: function(me, that) {
          if (isRight2(me)) {
            return me;
          }
          var ea = that();
          return isLeft2(ea) ? left3(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    map2 = function(f) {
      return function(fa) {
        return isLeft2(fa) ? fa : right3(f(fa.right));
      };
    };
    Functor2 = {
      URI: URI2,
      map: _map2
    };
    of = right3;
    Pointed = {
      URI: URI2,
      of
    };
    apW = function(fa) {
      return function(fab) {
        return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right3(fab.right(fa.right));
      };
    };
    ap2 = apW;
    Apply = {
      URI: URI2,
      map: _map2,
      ap: _ap
    };
    Applicative = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of
    };
    chainW = function(f) {
      return function(ma) {
        return isLeft2(ma) ? ma : f(ma.right);
      };
    };
    chain = chainW;
    Chain = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      chain: _chain
    };
    Monad = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of,
      chain: _chain
    };
    reduce = function(b, f) {
      return function(fa) {
        return isLeft2(fa) ? b : f(b, fa.right);
      };
    };
    foldMap = function(M) {
      return function(f) {
        return function(fa) {
          return isLeft2(fa) ? M.empty : f(fa.right);
        };
      };
    };
    reduceRight = function(b, f) {
      return function(fa) {
        return isLeft2(fa) ? b : f(fa.right, b);
      };
    };
    Foldable = {
      URI: URI2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    traverse = function(F) {
      return function(f) {
        return function(ta) {
          return isLeft2(ta) ? F.of(left3(ta.left)) : F.map(f(ta.right), right3);
        };
      };
    };
    sequence = function(F) {
      return function(ma) {
        return isLeft2(ma) ? F.of(left3(ma.left)) : F.map(ma.right, right3);
      };
    };
    Traversable = {
      URI: URI2,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence
    };
    bimap = function(f, g) {
      return function(fa) {
        return isLeft2(fa) ? left3(f(fa.left)) : right3(g(fa.right));
      };
    };
    mapLeft = function(f) {
      return function(fa) {
        return isLeft2(fa) ? left3(f(fa.left)) : fa;
      };
    };
    Bifunctor = {
      URI: URI2,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    altW = function(that) {
      return function(fa) {
        return isLeft2(fa) ? that() : fa;
      };
    };
    alt = altW;
    Alt = {
      URI: URI2,
      map: _map2,
      alt: _alt
    };
    extend = function(f) {
      return function(wa) {
        return isLeft2(wa) ? wa : right3(f(wa));
      };
    };
    Extend = {
      URI: URI2,
      map: _map2,
      extend: _extend
    };
    ChainRec = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      chain: _chain,
      chainRec: _chainRec
    };
    throwError = left3;
    MonadThrow = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of,
      chain: _chain,
      throwError
    };
    FromEither = {
      URI: URI2,
      fromEither: identity
    };
    fromPredicate2 = fromPredicate(FromEither);
    fromOption2 = fromOption(FromEither);
    isLeft2 = isLeft;
    isRight2 = isRight;
    matchW = function(onLeft, onRight) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    foldW = matchW;
    match = matchW;
    fold = match;
    getOrElseW = function(onLeft) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    getOrElse = getOrElseW;
    flap3 = flap(Functor2);
    apFirst2 = apFirst(Apply);
    apFirstW = apFirst2;
    apSecond2 = apSecond(Apply);
    apSecondW = apSecond2;
    chainFirst2 = chainFirst(Chain);
    chainFirstW = chainFirst2;
    flattenW = chainW(identity);
    flatten = flattenW;
    duplicate = extend(identity);
    fromOptionK2 = fromOptionK(FromEither);
    chainOptionK2 = chainOptionK(FromEither, Chain);
    filterOrElse2 = filterOrElse(FromEither, Chain);
    filterOrElseW = filterOrElse2;
    swap = function(ma) {
      return isLeft2(ma) ? right3(ma.left) : left3(ma.right);
    };
    orElseW = function(onLeft) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : ma;
      };
    };
    orElse = orElseW;
    fromNullable = function(e) {
      return function(a) {
        return a == null ? left3(e) : right3(a);
      };
    };
    tryCatch = function(f, onThrow) {
      try {
        return right3(f());
      } catch (e) {
        return left3(onThrow(e));
      }
    };
    tryCatchK = function(f, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return tryCatch(function() {
          return f.apply(void 0, a);
        }, onThrow);
      };
    };
    fromNullableK = function(e) {
      var from = fromNullable(e);
      return function(f) {
        return flow(f, from);
      };
    };
    chainNullableK = function(e) {
      var from = fromNullableK(e);
      return function(f) {
        return chain(from(f));
      };
    };
    toUnion = foldW(identity, identity);
    exists = function(predicate) {
      return function(ma) {
        return isLeft2(ma) ? false : predicate(ma.right);
      };
    };
    Do = of(emptyRecord);
    bindTo2 = bindTo(Functor2);
    let_2 = let_(Functor2);
    bind2 = bind(Chain);
    bindW = bind2;
    apS2 = apS(Apply);
    apSW = apS2;
    ApT = of(emptyReadonlyArray);
    traverseReadonlyNonEmptyArrayWithIndex = function(f) {
      return function(as) {
        var e = f(0, head(as));
        if (isLeft2(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
          var e_1 = f(i, as[i]);
          if (isLeft2(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return right3(out);
      };
    };
    traverseReadonlyArrayWithIndex = function(f) {
      var g = traverseReadonlyNonEmptyArrayWithIndex(f);
      return function(as) {
        return isNonEmpty(as) ? g(as) : ApT;
      };
    };
    traverseArrayWithIndex = traverseReadonlyArrayWithIndex;
    traverseArray = function(f) {
      return traverseReadonlyArrayWithIndex(function(_, a) {
        return f(a);
      });
    };
    sequenceArray = traverseArray(identity);
    stringifyJSON = function(u, onError) {
      return tryCatch(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    either = {
      URI: URI2,
      map: _map2,
      of,
      ap: _ap,
      chain: _chain,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence,
      bimap: _bimap,
      mapLeft: _mapLeft,
      alt: _alt,
      extend: _extend,
      chainRec: _chainRec,
      throwError
    };
    getApplySemigroup2 = getApplySemigroup(Apply);
    getApplyMonoid = getApplicativeMonoid(Applicative);
    getValidationSemigroup = function(SE, SA) {
      return getApplySemigroup(getApplicativeValidation(SE))(SA);
    };
    getValidationMonoid = function(SE, MA) {
      return getApplicativeMonoid(getApplicativeValidation(SE))(MA);
    };
  }
});

// node_modules/io-ts/es6/index.js
var es6_exports = {};
__export(es6_exports, {
  AnyArrayType: () => AnyArrayType,
  AnyDictionaryType: () => AnyDictionaryType,
  AnyType: () => AnyType,
  Array: () => UnknownArray,
  ArrayType: () => ArrayType,
  BigIntType: () => BigIntType,
  BooleanType: () => BooleanType,
  Dictionary: () => Dictionary,
  DictionaryType: () => DictionaryType,
  ExactType: () => ExactType,
  Function: () => Function,
  FunctionType: () => FunctionType,
  Int: () => Int,
  Integer: () => Integer,
  InterfaceType: () => InterfaceType,
  IntersectionType: () => IntersectionType,
  KeyofType: () => KeyofType,
  LiteralType: () => LiteralType,
  NeverType: () => NeverType,
  NullType: () => NullType,
  NumberType: () => NumberType,
  ObjectType: () => ObjectType,
  PartialType: () => PartialType,
  ReadonlyArrayType: () => ReadonlyArrayType,
  ReadonlyType: () => ReadonlyType,
  RecursiveType: () => RecursiveType,
  RefinementType: () => RefinementType,
  StrictType: () => StrictType,
  StringType: () => StringType,
  TaggedUnionType: () => TaggedUnionType,
  TupleType: () => TupleType,
  Type: () => Type,
  UndefinedType: () => UndefinedType,
  UnionType: () => UnionType,
  UnknownArray: () => UnknownArray,
  UnknownRecord: () => UnknownRecord,
  UnknownType: () => UnknownType,
  VoidType: () => VoidType,
  alias: () => alias,
  any: () => any,
  appendContext: () => appendContext,
  array: () => array,
  bigint: () => bigint,
  boolean: () => boolean,
  brand: () => brand,
  clean: () => clean,
  dictionary: () => dictionary,
  emptyTags: () => emptyTags,
  exact: () => exact,
  failure: () => failure,
  failures: () => failures,
  getContextEntry: () => getContextEntry,
  getDefaultContext: () => getDefaultContext,
  getDomainKeys: () => getDomainKeys,
  getFunctionName: () => getFunctionName,
  getIndex: () => getIndex,
  getTags: () => getTags,
  getValidationError: () => getValidationError,
  identity: () => identity2,
  interface: () => type,
  intersection: () => intersection,
  keyof: () => keyof,
  literal: () => literal,
  mergeAll: () => mergeAll,
  never: () => never,
  null: () => nullType,
  nullType: () => nullType,
  number: () => number,
  object: () => object,
  partial: () => partial,
  readonly: () => readonly,
  readonlyArray: () => readonlyArray,
  record: () => record,
  recursion: () => recursion,
  refinement: () => refinement,
  strict: () => strict,
  string: () => string,
  success: () => success,
  taggedUnion: () => taggedUnion,
  tuple: () => tuple2,
  type: () => type,
  undefined: () => undefinedType,
  union: () => union,
  unknown: () => unknown,
  void: () => voidType,
  voidType: () => voidType
});
function getFunctionName(f) {
  return f.displayName || f.name || "<function".concat(f.length, ">");
}
function getContextEntry(key, decoder) {
  return { key, type: decoder };
}
function appendContext(c, key, decoder, actual) {
  var len = c.length;
  var r = Array(len + 1);
  for (var i = 0; i < len; i++) {
    r[i] = c[i];
  }
  r[len] = { key, type: decoder, actual };
  return r;
}
function pushAll(xs, ys) {
  var l = ys.length;
  for (var i = 0; i < l; i++) {
    xs.push(ys[i]);
  }
}
function getNameFromProps(props) {
  return Object.keys(props).map(function(k) {
    return "".concat(k, ": ").concat(props[k].name);
  }).join(", ");
}
function useIdentity(codecs) {
  for (var i = 0; i < codecs.length; i++) {
    if (codecs[i].encode !== identity2) {
      return false;
    }
  }
  return true;
}
function getInterfaceTypeName(props) {
  return "{ ".concat(getNameFromProps(props), " }");
}
function getPartialTypeName(inner) {
  return "Partial<".concat(inner, ">");
}
function enumerableRecord(keys3, domain, codomain, name) {
  if (name === void 0) {
    name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
  }
  var len = keys3.length;
  return new DictionaryType(name, function(u) {
    return UnknownRecord.is(u) && keys3.every(function(k) {
      return codomain.is(u[k]);
    });
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = {};
    var errors = [];
    var changed = false;
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ok = o[k];
      var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
      if (isLeft2(codomainResult)) {
        pushAll(errors, codomainResult.left);
      } else {
        var vok = codomainResult.right;
        changed = changed || vok !== ok;
        a[k] = vok;
      }
    }
    return errors.length > 0 ? failures(errors) : success(changed || Object.keys(o).length !== len ? a : o);
  }, codomain.encode === identity2 ? identity2 : function(a) {
    var s = {};
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      s[k] = codomain.encode(a[k]);
    }
    return s;
  }, domain, codomain);
}
function getDomainKeys(domain) {
  var _a;
  if (isLiteralC(domain)) {
    var literal_1 = domain.value;
    if (string.is(literal_1)) {
      return _a = {}, _a[literal_1] = null, _a;
    }
  } else if (isKeyofC(domain)) {
    return domain.keys;
  } else if (isUnionC(domain)) {
    var keys3 = domain.types.map(function(type2) {
      return getDomainKeys(type2);
    });
    return keys3.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray2([{}], keys3, false));
  }
  return void 0;
}
function nonEnumerableRecord(domain, codomain, name) {
  if (name === void 0) {
    name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
  }
  return new DictionaryType(name, function(u) {
    if (UnknownRecord.is(u)) {
      return Object.keys(u).every(function(k) {
        return domain.is(k) && codomain.is(u[k]);
      });
    }
    return isAnyC(codomain) && Array.isArray(u);
  }, function(u, c) {
    if (UnknownRecord.is(u)) {
      var a = {};
      var errors = [];
      var keys3 = Object.keys(u);
      var len = keys3.length;
      var changed = false;
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var ok = u[k];
        var domainResult = domain.validate(k, appendContext(c, k, domain, k));
        if (isLeft2(domainResult)) {
          pushAll(errors, domainResult.left);
        } else {
          var vk = domainResult.right;
          changed = changed || vk !== k;
          k = vk;
          var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
          if (isLeft2(codomainResult)) {
            pushAll(errors, codomainResult.left);
          } else {
            var vok = codomainResult.right;
            changed = changed || vok !== ok;
            a[k] = vok;
          }
        }
      }
      return errors.length > 0 ? failures(errors) : success(changed ? a : u);
    }
    if (isAnyC(codomain) && Array.isArray(u)) {
      return success(u);
    }
    return failure(u, c);
  }, domain.encode === identity2 && codomain.encode === identity2 ? identity2 : function(a) {
    var s = {};
    var keys3 = Object.keys(a);
    var len = keys3.length;
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      s[String(domain.encode(k))] = codomain.encode(a[k]);
    }
    return s;
  }, domain, codomain);
}
function getUnionName(codecs) {
  return "(" + codecs.map(function(type2) {
    return type2.name;
  }).join(" | ") + ")";
}
function mergeAll(base, us) {
  var equal = true;
  var primitive = true;
  var baseIsNotADictionary = !UnknownRecord.is(base);
  for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
    var u = us_1[_i];
    if (u !== base) {
      equal = false;
    }
    if (UnknownRecord.is(u)) {
      primitive = false;
    }
  }
  if (equal) {
    return base;
  } else if (primitive) {
    return us[us.length - 1];
  }
  var r = {};
  for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
    var u = us_2[_a];
    for (var k in u) {
      if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
        r[k] = u[k];
      }
    }
  }
  return r;
}
function getProps(codec) {
  switch (codec._tag) {
    case "RefinementType":
    case "ReadonlyType":
      return getProps(codec.type);
    case "InterfaceType":
    case "StrictType":
    case "PartialType":
      return codec.props;
    case "IntersectionType":
      return codec.types.reduce(function(props, type2) {
        return Object.assign(props, getProps(type2));
      }, {});
  }
}
function stripKeys(o, props) {
  var keys3 = Object.getOwnPropertyNames(o);
  var shouldStrip = false;
  var r = {};
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (!hasOwnProperty.call(props, key)) {
      shouldStrip = true;
    } else {
      r[key] = o[key];
    }
  }
  return shouldStrip ? r : o;
}
function getExactTypeName(codec) {
  if (isTypeC(codec)) {
    return "{| ".concat(getNameFromProps(codec.props), " |}");
  } else if (isPartialC(codec)) {
    return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
  }
  return "Exact<".concat(codec.name, ">");
}
function isNonEmpty2(as) {
  return as.length > 0;
}
function intersect(a, b) {
  var r = [];
  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
    var v = a_1[_i];
    if (b.indexOf(v) !== -1) {
      r.push(v);
    }
  }
  return r;
}
function mergeTags(a, b) {
  if (a === emptyTags) {
    return b;
  }
  if (b === emptyTags) {
    return a;
  }
  var r = Object.assign({}, a);
  for (var k in b) {
    if (hasOwnProperty.call(a, k)) {
      var intersection_1 = intersect(a[k], b[k]);
      if (isNonEmpty2(intersection_1)) {
        r[k] = intersection_1;
      } else {
        r = emptyTags;
        break;
      }
    } else {
      r[k] = b[k];
    }
  }
  return r;
}
function intersectTags(a, b) {
  if (a === emptyTags || b === emptyTags) {
    return emptyTags;
  }
  var r = emptyTags;
  for (var k in a) {
    if (hasOwnProperty.call(b, k)) {
      var intersection_2 = intersect(a[k], b[k]);
      if (intersection_2.length === 0) {
        if (r === emptyTags) {
          r = {};
        }
        r[k] = a[k].concat(b[k]);
      }
    }
  }
  return r;
}
function isAnyC(codec) {
  return codec._tag === "AnyType";
}
function isLiteralC(codec) {
  return codec._tag === "LiteralType";
}
function isKeyofC(codec) {
  return codec._tag === "KeyofType";
}
function isTypeC(codec) {
  return codec._tag === "InterfaceType";
}
function isPartialC(codec) {
  return codec._tag === "PartialType";
}
function isStrictC(codec) {
  return codec._tag === "StrictType";
}
function isExactC(codec) {
  return codec._tag === "ExactType";
}
function isRefinementC(codec) {
  return codec._tag === "RefinementType";
}
function isIntersectionC(codec) {
  return codec._tag === "IntersectionType";
}
function isUnionC(codec) {
  return codec._tag === "UnionType";
}
function isRecursiveC(codec) {
  return codec._tag === "RecursiveType";
}
function getTags(codec) {
  if (lazyCodecs.indexOf(codec) !== -1) {
    return emptyTags;
  }
  if (isTypeC(codec) || isStrictC(codec)) {
    var index = emptyTags;
    for (var k in codec.props) {
      var prop = codec.props[k];
      if (isLiteralC(prop)) {
        if (index === emptyTags) {
          index = {};
        }
        index[k] = [prop.value];
      }
    }
    return index;
  } else if (isExactC(codec) || isRefinementC(codec)) {
    return getTags(codec.type);
  } else if (isIntersectionC(codec)) {
    return codec.types.reduce(function(tags2, codec2) {
      return mergeTags(tags2, getTags(codec2));
    }, emptyTags);
  } else if (isUnionC(codec)) {
    return codec.types.slice(1).reduce(function(tags2, codec2) {
      return intersectTags(tags2, getTags(codec2));
    }, getTags(codec.types[0]));
  } else if (isRecursiveC(codec)) {
    lazyCodecs.push(codec);
    var tags = getTags(codec.type);
    lazyCodecs.pop();
    return tags;
  }
  return emptyTags;
}
function getIndex(codecs) {
  var tags = getTags(codecs[0]);
  var keys3 = Object.keys(tags);
  var len = codecs.length;
  var _loop_1 = function(k2) {
    var all = tags[k2].slice();
    var index = [tags[k2]];
    for (var i = 1; i < len; i++) {
      var codec = codecs[i];
      var ctags = getTags(codec);
      var values = ctags[k2];
      if (values === void 0) {
        return "continue-keys";
      } else {
        if (values.some(function(v) {
          return all.indexOf(v) !== -1;
        })) {
          return "continue-keys";
        } else {
          all.push.apply(all, values);
          index.push(values);
        }
      }
    }
    return { value: [k2, index] };
  };
  keys:
    for (var _i = 0, keys_1 = keys3; _i < keys_1.length; _i++) {
      var k = keys_1[_i];
      var state_1 = _loop_1(k);
      if (typeof state_1 === "object")
        return state_1.value;
      switch (state_1) {
        case "continue-keys":
          continue keys;
      }
    }
  return void 0;
}
function literal(value, name) {
  if (name === void 0) {
    name = JSON.stringify(value);
  }
  var is = function(u) {
    return u === value;
  };
  return new LiteralType(name, is, function(u, c) {
    return is(u) ? success(value) : failure(u, c);
  }, identity2, value);
}
function keyof(keys3, name) {
  if (name === void 0) {
    name = Object.keys(keys3).map(function(k) {
      return JSON.stringify(k);
    }).join(" | ");
  }
  var is = function(u) {
    return string.is(u) && hasOwnProperty.call(keys3, u);
  };
  return new KeyofType(name, is, function(u, c) {
    return is(u) ? success(u) : failure(u, c);
  }, identity2, keys3);
}
function brand(codec, predicate, name) {
  return refinement(codec, predicate, name);
}
function recursion(name, definition) {
  var cache;
  var runDefinition = function() {
    if (!cache) {
      cache = definition(Self);
      cache.name = name;
    }
    return cache;
  };
  var Self = new RecursiveType(name, function(u) {
    return runDefinition().is(u);
  }, function(u, c) {
    return runDefinition().validate(u, c);
  }, function(a) {
    return runDefinition().encode(a);
  }, runDefinition);
  return Self;
}
function array(item, name) {
  if (name === void 0) {
    name = "Array<".concat(item.name, ">");
  }
  return new ArrayType(name, function(u) {
    return UnknownArray.is(u) && u.every(item.is);
  }, function(u, c) {
    var e = UnknownArray.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var us = e.right;
    var len = us.length;
    var as = us;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var ui = us[i];
      var result = item.validate(ui, appendContext(c, String(i), item, ui));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var ai = result.right;
        if (ai !== ui) {
          if (as === us) {
            as = us.slice();
          }
          as[i] = ai;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(as);
  }, item.encode === identity2 ? identity2 : function(a) {
    return a.map(item.encode);
  }, item);
}
function type(props, name) {
  if (name === void 0) {
    name = getInterfaceTypeName(props);
  }
  var keys3 = Object.keys(props);
  var types = keys3.map(function(key) {
    return props[key];
  });
  var len = keys3.length;
  return new InterfaceType(name, function(u) {
    if (UnknownRecord.is(u)) {
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var uk = u[k];
        if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = o;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      var type_1 = types[i];
      var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var vak = result.right;
        if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a, k)) {
          if (a === o) {
            a = __assign({}, o);
          }
          a[k] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a);
  }, useIdentity(types) ? identity2 : function(a) {
    var s = __assign({}, a);
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var encode = types[i].encode;
      if (encode !== identity2) {
        s[k] = encode(a[k]);
      }
    }
    return s;
  }, props);
}
function partial(props, name) {
  if (name === void 0) {
    name = getPartialTypeName(getInterfaceTypeName(props));
  }
  var keys3 = Object.keys(props);
  var types = keys3.map(function(key) {
    return props[key];
  });
  var len = keys3.length;
  return new PartialType(name, function(u) {
    if (UnknownRecord.is(u)) {
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var uk = u[k];
        if (uk !== void 0 && !props[k].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = o;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      var type_2 = props[k];
      var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
      if (isLeft2(result)) {
        if (ak !== void 0) {
          pushAll(errors, result.left);
        }
      } else {
        var vak = result.right;
        if (vak !== ak) {
          if (a === o) {
            a = __assign({}, o);
          }
          a[k] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a);
  }, useIdentity(types) ? identity2 : function(a) {
    var s = __assign({}, a);
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      if (ak !== void 0) {
        s[k] = types[i].encode(ak);
      }
    }
    return s;
  }, props);
}
function record(domain, codomain, name) {
  var keys3 = getDomainKeys(domain);
  return keys3 ? enumerableRecord(Object.keys(keys3), domain, codomain, name) : nonEnumerableRecord(domain, codomain, name);
}
function union(codecs, name) {
  if (name === void 0) {
    name = getUnionName(codecs);
  }
  var index = getIndex(codecs);
  if (index !== void 0 && codecs.length > 0) {
    var tag_1 = index[0], groups_1 = index[1];
    var len_1 = groups_1.length;
    var find_1 = function(value) {
      for (var i = 0; i < len_1; i++) {
        if (groups_1[i].indexOf(value) !== -1) {
          return i;
        }
      }
      return void 0;
    };
    return new TaggedUnionType(name, function(u) {
      if (UnknownRecord.is(u)) {
        var i = find_1(u[tag_1]);
        return i !== void 0 ? codecs[i].is(u) : false;
      }
      return false;
    }, function(u, c) {
      var e = UnknownRecord.validate(u, c);
      if (isLeft2(e)) {
        return e;
      }
      var r = e.right;
      var i = find_1(r[tag_1]);
      if (i === void 0) {
        return failure(u, c);
      }
      var codec = codecs[i];
      return codec.validate(r, appendContext(c, String(i), codec, r));
    }, useIdentity(codecs) ? identity2 : function(a) {
      var i = find_1(a[tag_1]);
      if (i === void 0) {
        throw new Error("no codec found to encode value in union codec ".concat(name));
      } else {
        return codecs[i].encode(a);
      }
    }, codecs, tag_1);
  } else {
    return new UnionType(name, function(u) {
      return codecs.some(function(type2) {
        return type2.is(u);
      });
    }, function(u, c) {
      var errors = [];
      for (var i = 0; i < codecs.length; i++) {
        var codec = codecs[i];
        var result = codec.validate(u, appendContext(c, String(i), codec, u));
        if (isLeft2(result)) {
          pushAll(errors, result.left);
        } else {
          return success(result.right);
        }
      }
      return failures(errors);
    }, useIdentity(codecs) ? identity2 : function(a) {
      for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
        var codec = codecs_1[_i];
        if (codec.is(a)) {
          return codec.encode(a);
        }
      }
      throw new Error("no codec found to encode value in union type ".concat(name));
    }, codecs);
  }
}
function intersection(codecs, name) {
  if (name === void 0) {
    name = "(".concat(codecs.map(function(type2) {
      return type2.name;
    }).join(" & "), ")");
  }
  var len = codecs.length;
  return new IntersectionType(name, function(u) {
    return codecs.every(function(type2) {
      return type2.is(u);
    });
  }, codecs.length === 0 ? success : function(u, c) {
    var us = [];
    var errors = [];
    for (var i = 0; i < len; i++) {
      var codec = codecs[i];
      var result = codec.validate(u, appendContext(c, String(i), codec, u));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        us.push(result.right);
      }
    }
    return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));
  }, codecs.length === 0 ? identity2 : function(a) {
    return mergeAll(a, codecs.map(function(codec) {
      return codec.encode(a);
    }));
  }, codecs);
}
function tuple2(codecs, name) {
  if (name === void 0) {
    name = "[".concat(codecs.map(function(type2) {
      return type2.name;
    }).join(", "), "]");
  }
  var len = codecs.length;
  return new TupleType(name, function(u) {
    return UnknownArray.is(u) && u.length === len && codecs.every(function(type2, i) {
      return type2.is(u[i]);
    });
  }, function(u, c) {
    var e = UnknownArray.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var us = e.right;
    var as = us.length > len ? us.slice(0, len) : us;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var a = us[i];
      var type_3 = codecs[i];
      var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var va = result.right;
        if (va !== a) {
          if (as === us) {
            as = us.slice();
          }
          as[i] = va;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(as);
  }, useIdentity(codecs) ? identity2 : function(a) {
    return codecs.map(function(type2, i) {
      return type2.encode(a[i]);
    });
  }, codecs);
}
function readonly(codec, name) {
  if (name === void 0) {
    name = "Readonly<".concat(codec.name, ">");
  }
  return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
}
function readonlyArray(item, name) {
  if (name === void 0) {
    name = "ReadonlyArray<".concat(item.name, ">");
  }
  var codec = array(item);
  return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
}
function exact(codec, name) {
  if (name === void 0) {
    name = getExactTypeName(codec);
  }
  var props = getProps(codec);
  return new ExactType(name, codec.is, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var ce = codec.validate(u, c);
    if (isLeft2(ce)) {
      return ce;
    }
    return right3(stripKeys(ce.right, props));
  }, function(a) {
    return codec.encode(stripKeys(a, props));
  }, codec);
}
function refinement(codec, predicate, name) {
  if (name === void 0) {
    name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
  }
  return new RefinementType(name, function(u) {
    return codec.is(u) && predicate(u);
  }, function(i, c) {
    var e = codec.validate(i, c);
    if (isLeft2(e)) {
      return e;
    }
    var a = e.right;
    return predicate(a) ? success(a) : failure(a, c);
  }, codec.encode, codec, predicate);
}
function clean(codec) {
  return codec;
}
function alias(codec) {
  return function() {
    return codec;
  };
}
var __extends, __assign, __spreadArray2, failures, failure, success, Type, identity2, hasOwnProperty, emptyTags, lazyCodecs, NullType, nullType, UndefinedType, undefinedType, VoidType, voidType, UnknownType, unknown, StringType, string, NumberType, number, BigIntType, bigint, BooleanType, boolean, AnyArrayType, UnknownArray, AnyDictionaryType, UnknownRecord, LiteralType, KeyofType, RefinementType, Int, RecursiveType, ArrayType, InterfaceType, PartialType, DictionaryType, UnionType, IntersectionType, TupleType, ReadonlyType, ReadonlyArrayType, strict, ExactType, FunctionType, Function, NeverType, never, AnyType, any, Integer, TaggedUnionType, taggedUnion, getValidationError, getDefaultContext, Dictionary, ObjectType, object, dictionary, StrictType;
var init_es6 = __esm({
  "node_modules/io-ts/es6/index.js"() {
    init_shim();
    init_Either();
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    failures = left3;
    failure = function(value, context, message) {
      return failures([{ value, context, message }]);
    };
    success = right3;
    Type = /** @class */
    function() {
      function Type2(name, is, validate, encode) {
        this.name = name;
        this.is = is;
        this.validate = validate;
        this.encode = encode;
        this.decode = this.decode.bind(this);
      }
      Type2.prototype.pipe = function(ab, name) {
        var _this = this;
        if (name === void 0) {
          name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
        }
        return new Type2(name, ab.is, function(i, c) {
          var e = _this.validate(i, c);
          if (isLeft2(e)) {
            return e;
          }
          return ab.validate(e.right, c);
        }, this.encode === identity2 && ab.encode === identity2 ? identity2 : function(b) {
          return _this.encode(ab.encode(b));
        });
      };
      Type2.prototype.asDecoder = function() {
        return this;
      };
      Type2.prototype.asEncoder = function() {
        return this;
      };
      Type2.prototype.decode = function(i) {
        return this.validate(i, [{ key: "", type: this, actual: i }]);
      };
      return Type2;
    }();
    identity2 = function(a) {
      return a;
    };
    hasOwnProperty = Object.prototype.hasOwnProperty;
    emptyTags = {};
    lazyCodecs = [];
    NullType = /** @class */
    function(_super) {
      __extends(NullType2, _super);
      function NullType2() {
        var _this = _super.call(this, "null", function(u) {
          return u === null;
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "NullType";
        return _this;
      }
      return NullType2;
    }(Type);
    nullType = new NullType();
    UndefinedType = /** @class */
    function(_super) {
      __extends(UndefinedType2, _super);
      function UndefinedType2() {
        var _this = _super.call(this, "undefined", function(u) {
          return u === void 0;
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "UndefinedType";
        return _this;
      }
      return UndefinedType2;
    }(Type);
    undefinedType = new UndefinedType();
    VoidType = /** @class */
    function(_super) {
      __extends(VoidType2, _super);
      function VoidType2() {
        var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, identity2) || this;
        _this._tag = "VoidType";
        return _this;
      }
      return VoidType2;
    }(Type);
    voidType = new VoidType();
    UnknownType = /** @class */
    function(_super) {
      __extends(UnknownType2, _super);
      function UnknownType2() {
        var _this = _super.call(this, "unknown", function(_) {
          return true;
        }, success, identity2) || this;
        _this._tag = "UnknownType";
        return _this;
      }
      return UnknownType2;
    }(Type);
    unknown = new UnknownType();
    StringType = /** @class */
    function(_super) {
      __extends(StringType2, _super);
      function StringType2() {
        var _this = _super.call(this, "string", function(u) {
          return typeof u === "string";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "StringType";
        return _this;
      }
      return StringType2;
    }(Type);
    string = new StringType();
    NumberType = /** @class */
    function(_super) {
      __extends(NumberType2, _super);
      function NumberType2() {
        var _this = _super.call(this, "number", function(u) {
          return typeof u === "number";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "NumberType";
        return _this;
      }
      return NumberType2;
    }(Type);
    number = new NumberType();
    BigIntType = /** @class */
    function(_super) {
      __extends(BigIntType2, _super);
      function BigIntType2() {
        var _this = _super.call(
          this,
          "bigint",
          // tslint:disable-next-line: valid-typeof
          function(u) {
            return typeof u === "bigint";
          },
          function(u, c) {
            return _this.is(u) ? success(u) : failure(u, c);
          },
          identity2
        ) || this;
        _this._tag = "BigIntType";
        return _this;
      }
      return BigIntType2;
    }(Type);
    bigint = new BigIntType();
    BooleanType = /** @class */
    function(_super) {
      __extends(BooleanType2, _super);
      function BooleanType2() {
        var _this = _super.call(this, "boolean", function(u) {
          return typeof u === "boolean";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "BooleanType";
        return _this;
      }
      return BooleanType2;
    }(Type);
    boolean = new BooleanType();
    AnyArrayType = /** @class */
    function(_super) {
      __extends(AnyArrayType2, _super);
      function AnyArrayType2() {
        var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "AnyArrayType";
        return _this;
      }
      return AnyArrayType2;
    }(Type);
    UnknownArray = new AnyArrayType();
    AnyDictionaryType = /** @class */
    function(_super) {
      __extends(AnyDictionaryType2, _super);
      function AnyDictionaryType2() {
        var _this = _super.call(this, "UnknownRecord", function(u) {
          return u !== null && typeof u === "object" && !Array.isArray(u);
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "AnyDictionaryType";
        return _this;
      }
      return AnyDictionaryType2;
    }(Type);
    UnknownRecord = new AnyDictionaryType();
    LiteralType = /** @class */
    function(_super) {
      __extends(LiteralType2, _super);
      function LiteralType2(name, is, validate, encode, value) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.value = value;
        _this._tag = "LiteralType";
        return _this;
      }
      return LiteralType2;
    }(Type);
    KeyofType = /** @class */
    function(_super) {
      __extends(KeyofType2, _super);
      function KeyofType2(name, is, validate, encode, keys3) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.keys = keys3;
        _this._tag = "KeyofType";
        return _this;
      }
      return KeyofType2;
    }(Type);
    RefinementType = /** @class */
    function(_super) {
      __extends(RefinementType2, _super);
      function RefinementType2(name, is, validate, encode, type2, predicate) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this.predicate = predicate;
        _this._tag = "RefinementType";
        return _this;
      }
      return RefinementType2;
    }(Type);
    Int = brand(number, function(n) {
      return Number.isInteger(n);
    }, "Int");
    RecursiveType = /** @class */
    function(_super) {
      __extends(RecursiveType2, _super);
      function RecursiveType2(name, is, validate, encode, runDefinition) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.runDefinition = runDefinition;
        _this._tag = "RecursiveType";
        return _this;
      }
      return RecursiveType2;
    }(Type);
    Object.defineProperty(RecursiveType.prototype, "type", {
      get: function() {
        return this.runDefinition();
      },
      enumerable: true,
      configurable: true
    });
    ArrayType = /** @class */
    function(_super) {
      __extends(ArrayType2, _super);
      function ArrayType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ArrayType";
        return _this;
      }
      return ArrayType2;
    }(Type);
    InterfaceType = /** @class */
    function(_super) {
      __extends(InterfaceType2, _super);
      function InterfaceType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "InterfaceType";
        return _this;
      }
      return InterfaceType2;
    }(Type);
    PartialType = /** @class */
    function(_super) {
      __extends(PartialType2, _super);
      function PartialType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "PartialType";
        return _this;
      }
      return PartialType2;
    }(Type);
    DictionaryType = /** @class */
    function(_super) {
      __extends(DictionaryType2, _super);
      function DictionaryType2(name, is, validate, encode, domain, codomain) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.domain = domain;
        _this.codomain = codomain;
        _this._tag = "DictionaryType";
        return _this;
      }
      return DictionaryType2;
    }(Type);
    UnionType = /** @class */
    function(_super) {
      __extends(UnionType2, _super);
      function UnionType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "UnionType";
        return _this;
      }
      return UnionType2;
    }(Type);
    IntersectionType = /** @class */
    function(_super) {
      __extends(IntersectionType2, _super);
      function IntersectionType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "IntersectionType";
        return _this;
      }
      return IntersectionType2;
    }(Type);
    TupleType = /** @class */
    function(_super) {
      __extends(TupleType2, _super);
      function TupleType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "TupleType";
        return _this;
      }
      return TupleType2;
    }(Type);
    ReadonlyType = /** @class */
    function(_super) {
      __extends(ReadonlyType2, _super);
      function ReadonlyType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ReadonlyType";
        return _this;
      }
      return ReadonlyType2;
    }(Type);
    ReadonlyArrayType = /** @class */
    function(_super) {
      __extends(ReadonlyArrayType2, _super);
      function ReadonlyArrayType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ReadonlyArrayType";
        return _this;
      }
      return ReadonlyArrayType2;
    }(Type);
    strict = function(props, name) {
      return exact(type(props), name);
    };
    ExactType = /** @class */
    function(_super) {
      __extends(ExactType2, _super);
      function ExactType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ExactType";
        return _this;
      }
      return ExactType2;
    }(Type);
    FunctionType = /** @class */
    function(_super) {
      __extends(FunctionType2, _super);
      function FunctionType2() {
        var _this = _super.call(
          this,
          "Function",
          // tslint:disable-next-line:strict-type-predicates
          function(u) {
            return typeof u === "function";
          },
          function(u, c) {
            return _this.is(u) ? success(u) : failure(u, c);
          },
          identity2
        ) || this;
        _this._tag = "FunctionType";
        return _this;
      }
      return FunctionType2;
    }(Type);
    Function = new FunctionType();
    NeverType = /** @class */
    function(_super) {
      __extends(NeverType2, _super);
      function NeverType2() {
        var _this = _super.call(
          this,
          "never",
          function(_) {
            return false;
          },
          function(u, c) {
            return failure(u, c);
          },
          /* istanbul ignore next */
          function() {
            throw new Error("cannot encode never");
          }
        ) || this;
        _this._tag = "NeverType";
        return _this;
      }
      return NeverType2;
    }(Type);
    never = new NeverType();
    AnyType = /** @class */
    function(_super) {
      __extends(AnyType2, _super);
      function AnyType2() {
        var _this = _super.call(this, "any", function(_) {
          return true;
        }, success, identity2) || this;
        _this._tag = "AnyType";
        return _this;
      }
      return AnyType2;
    }(Type);
    any = new AnyType();
    Integer = refinement(number, Number.isInteger, "Integer");
    TaggedUnionType = /** @class */
    function(_super) {
      __extends(TaggedUnionType2, _super);
      function TaggedUnionType2(name, is, validate, encode, codecs, tag) {
        var _this = _super.call(this, name, is, validate, encode, codecs) || this;
        _this.tag = tag;
        return _this;
      }
      return TaggedUnionType2;
    }(UnionType);
    taggedUnion = function(tag, codecs, name) {
      if (name === void 0) {
        name = getUnionName(codecs);
      }
      var U = union(codecs, name);
      if (U instanceof TaggedUnionType) {
        return U;
      } else {
        console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
      }
    };
    getValidationError = function(value, context) {
      return {
        value,
        context
      };
    };
    getDefaultContext = function(decoder) {
      return [
        { key: "", type: decoder }
      ];
    };
    Dictionary = UnknownRecord;
    ObjectType = /** @class */
    function(_super) {
      __extends(ObjectType2, _super);
      function ObjectType2() {
        var _this = _super.call(this, "object", function(u) {
          return u !== null && typeof u === "object";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "ObjectType";
        return _this;
      }
      return ObjectType2;
    }(Type);
    object = new ObjectType();
    dictionary = record;
    StrictType = /** @class */
    function(_super) {
      __extends(StrictType2, _super);
      function StrictType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "StrictType";
        return _this;
      }
      return StrictType2;
    }(Type);
  }
});

// node_modules/fp-ts/lib/function.js
var require_function = __commonJS({
  "node_modules/fp-ts/lib/function.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    var getBooleanAlgebra = function(B) {
      return function() {
        return {
          meet: function(x, y) {
            return function(a) {
              return B.meet(x(a), y(a));
            };
          },
          join: function(x, y) {
            return function(a) {
              return B.join(x(a), y(a));
            };
          },
          zero: function() {
            return B.zero;
          },
          one: function() {
            return B.one;
          },
          implies: function(x, y) {
            return function(a) {
              return B.implies(x(a), y(a));
            };
          },
          not: function(x) {
            return function(a) {
              return B.not(x(a));
            };
          }
        };
      };
    };
    exports.getBooleanAlgebra = getBooleanAlgebra;
    var getSemigroup6 = function(S) {
      return function() {
        return {
          concat: function(f, g) {
            return function(a) {
              return S.concat(f(a), g(a));
            };
          }
        };
      };
    };
    exports.getSemigroup = getSemigroup6;
    var getMonoid6 = function(M) {
      var getSemigroupM = (0, exports.getSemigroup)(M);
      return function() {
        return {
          concat: getSemigroupM().concat,
          empty: function() {
            return M.empty;
          }
        };
      };
    };
    exports.getMonoid = getMonoid6;
    var getSemiring = function(S) {
      return {
        add: function(f, g) {
          return function(x) {
            return S.add(f(x), g(x));
          };
        },
        zero: function() {
          return S.zero;
        },
        mul: function(f, g) {
          return function(x) {
            return S.mul(f(x), g(x));
          };
        },
        one: function() {
          return S.one;
        }
      };
    };
    exports.getSemiring = getSemiring;
    var getRing = function(R) {
      var S = (0, exports.getSemiring)(R);
      return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function(f, g) {
          return function(x) {
            return R.sub(f(x), g(x));
          };
        }
      };
    };
    exports.getRing = getRing;
    var apply = function(a) {
      return function(f) {
        return f(a);
      };
    };
    exports.apply = apply;
    function identity3(a) {
      return a;
    }
    exports.identity = identity3;
    exports.unsafeCoerce = identity3;
    function constant3(a) {
      return function() {
        return a;
      };
    }
    exports.constant = constant3;
    exports.constTrue = constant3(true);
    exports.constFalse = constant3(false);
    exports.constNull = constant3(null);
    exports.constUndefined = constant3(void 0);
    exports.constVoid = exports.constUndefined;
    function flip(f) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length > 1) {
          return f(args[1], args[0]);
        }
        return function(a) {
          return f(a)(args[0]);
        };
      };
    }
    exports.flip = flip;
    function flow2(ab, bc, cd, de, ef, fg, gh, hi, ij) {
      switch (arguments.length) {
        case 1:
          return ab;
        case 2:
          return function() {
            return bc(ab.apply(this, arguments));
          };
        case 3:
          return function() {
            return cd(bc(ab.apply(this, arguments)));
          };
        case 4:
          return function() {
            return de(cd(bc(ab.apply(this, arguments))));
          };
        case 5:
          return function() {
            return ef(de(cd(bc(ab.apply(this, arguments)))));
          };
        case 6:
          return function() {
            return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
          };
        case 7:
          return function() {
            return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
          };
        case 8:
          return function() {
            return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
          };
        case 9:
          return function() {
            return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
          };
      }
      return;
    }
    exports.flow = flow2;
    function tuple3() {
      var t = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        t[_i] = arguments[_i];
      }
      return t;
    }
    exports.tuple = tuple3;
    function increment(n) {
      return n + 1;
    }
    exports.increment = increment;
    function decrement(n) {
      return n - 1;
    }
    exports.decrement = decrement;
    function absurd(_) {
      throw new Error("Called `absurd` function which should be uncallable");
    }
    exports.absurd = absurd;
    function tupled(f) {
      return function(a) {
        return f.apply(void 0, a);
      };
    }
    exports.tupled = tupled;
    function untupled(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return f(a);
      };
    }
    exports.untupled = untupled;
    function pipe3(a, ab, bc, cd, de, ef, fg, gh, hi) {
      switch (arguments.length) {
        case 1:
          return a;
        case 2:
          return ab(a);
        case 3:
          return bc(ab(a));
        case 4:
          return cd(bc(ab(a)));
        case 5:
          return de(cd(bc(ab(a))));
        case 6:
          return ef(de(cd(bc(ab(a)))));
        case 7:
          return fg(ef(de(cd(bc(ab(a))))));
        case 8:
          return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
          return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
          var ret = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            ret = arguments[i](ret);
          }
          return ret;
        }
      }
    }
    exports.pipe = pipe3;
    exports.hole = absurd;
    var SK2 = function(_, b) {
      return b;
    };
    exports.SK = SK2;
    function not2(predicate) {
      return function(a) {
        return !predicate(a);
      };
    }
    exports.not = not2;
    var getEndomorphismMonoid = function() {
      return {
        concat: function(first2, second) {
          return flow2(first2, second);
        },
        empty: identity3
      };
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
  }
});

// node_modules/fp-ts/lib/internal.js
var require_internal = __commonJS({
  "node_modules/fp-ts/lib/internal.js"(exports) {
    "use strict";
    init_shim();
    var __spreadArray6 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
    var isNone3 = function(fa) {
      return fa._tag === "None";
    };
    exports.isNone = isNone3;
    var isSome3 = function(fa) {
      return fa._tag === "Some";
    };
    exports.isSome = isSome3;
    exports.none = { _tag: "None" };
    var some6 = function(a) {
      return { _tag: "Some", value: a };
    };
    exports.some = some6;
    var isLeft3 = function(ma) {
      return ma._tag === "Left";
    };
    exports.isLeft = isLeft3;
    var isRight3 = function(ma) {
      return ma._tag === "Right";
    };
    exports.isRight = isRight3;
    var left4 = function(e) {
      return { _tag: "Left", left: e };
    };
    exports.left = left4;
    var right4 = function(a) {
      return { _tag: "Right", right: a };
    };
    exports.right = right4;
    var singleton4 = function(a) {
      return [a];
    };
    exports.singleton = singleton4;
    var isNonEmpty7 = function(as) {
      return as.length > 0;
    };
    exports.isNonEmpty = isNonEmpty7;
    var head6 = function(as) {
      return as[0];
    };
    exports.head = head6;
    var tail5 = function(as) {
      return as.slice(1);
    };
    exports.tail = tail5;
    exports.emptyReadonlyArray = [];
    exports.emptyRecord = {};
    exports.has = Object.prototype.hasOwnProperty;
    var fromReadonlyNonEmptyArray3 = function(as) {
      return __spreadArray6([as[0]], as.slice(1), true);
    };
    exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray3;
  }
});

// node_modules/fp-ts/lib/Apply.js
var require_Apply = __commonJS({
  "node_modules/fp-ts/lib/Apply.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function ap9(F, G) {
      return function(fa) {
        return function(fab) {
          return F.ap(F.map(fab, function(gab) {
            return function(ga) {
              return G.ap(gab, ga);
            };
          }), fa);
        };
      };
    }
    exports.ap = ap9;
    function apFirst8(A) {
      return function(second) {
        return function(first2) {
          return A.ap(A.map(first2, function(a) {
            return function() {
              return a;
            };
          }), second);
        };
      };
    }
    exports.apFirst = apFirst8;
    function apSecond8(A) {
      return function(second) {
        return function(first2) {
          return A.ap(A.map(first2, function() {
            return function(b) {
              return b;
            };
          }), second);
        };
      };
    }
    exports.apSecond = apSecond8;
    function apS8(F) {
      return function(name, fb) {
        return function(fa) {
          return F.ap(F.map(fa, function(a) {
            return function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            };
          }), fb);
        };
      };
    }
    exports.apS = apS8;
    function getApplySemigroup4(F) {
      return function(S) {
        return {
          concat: function(first2, second) {
            return F.ap(F.map(first2, function(x) {
              return function(y) {
                return S.concat(x, y);
              };
            }), second);
          }
        };
      };
    }
    exports.getApplySemigroup = getApplySemigroup4;
    function curried(f, n, acc) {
      return function(x) {
        var combined = Array(acc.length + 1);
        for (var i = 0; i < acc.length; i++) {
          combined[i] = acc[i];
        }
        combined[acc.length] = x;
        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
      };
    }
    var tupleConstructors = {
      1: function(a) {
        return [a];
      },
      2: function(a) {
        return function(b) {
          return [a, b];
        };
      },
      3: function(a) {
        return function(b) {
          return function(c) {
            return [a, b, c];
          };
        };
      },
      4: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return [a, b, c, d];
            };
          };
        };
      },
      5: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return function(e) {
                return [a, b, c, d, e];
              };
            };
          };
        };
      }
    };
    function getTupleConstructor(len) {
      if (!_.has.call(tupleConstructors, len)) {
        tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
      }
      return tupleConstructors[len];
    }
    function sequenceT(F) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var len = args.length;
        var f = getTupleConstructor(len);
        var fas = F.map(args[0], f);
        for (var i = 1; i < len; i++) {
          fas = F.ap(fas, args[i]);
        }
        return fas;
      };
    }
    exports.sequenceT = sequenceT;
    function getRecordConstructor(keys3) {
      var len = keys3.length;
      switch (len) {
        case 1:
          return function(a) {
            var _a;
            return _a = {}, _a[keys3[0]] = a, _a;
          };
        case 2:
          return function(a) {
            return function(b) {
              var _a;
              return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a;
            };
          };
        case 3:
          return function(a) {
            return function(b) {
              return function(c) {
                var _a;
                return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a;
              };
            };
          };
        case 4:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  var _a;
                  return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a[keys3[3]] = d, _a;
                };
              };
            };
          };
        case 5:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  return function(e) {
                    var _a;
                    return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a[keys3[3]] = d, _a[keys3[4]] = e, _a;
                  };
                };
              };
            };
          };
        default:
          return curried(function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var r = {};
            for (var i = 0; i < len; i++) {
              r[keys3[i]] = args[i];
            }
            return r;
          }, len - 1, []);
      }
    }
    function sequenceS(F) {
      return function(r) {
        var keys3 = Object.keys(r);
        var len = keys3.length;
        var f = getRecordConstructor(keys3);
        var fr = F.map(r[keys3[0]], f);
        for (var i = 1; i < len; i++) {
          fr = F.ap(fr, r[keys3[i]]);
        }
        return fr;
      };
    }
    exports.sequenceS = sequenceS;
  }
});

// node_modules/fp-ts/lib/Functor.js
var require_Functor = __commonJS({
  "node_modules/fp-ts/lib/Functor.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;
    var function_1 = require_function();
    function map11(F, G) {
      return function(f) {
        return function(fa) {
          return F.map(fa, function(ga) {
            return G.map(ga, f);
          });
        };
      };
    }
    exports.map = map11;
    function flap11(F) {
      return function(a) {
        return function(fab) {
          return F.map(fab, function(f) {
            return f(a);
          });
        };
      };
    }
    exports.flap = flap11;
    function bindTo8(F) {
      return function(name) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a;
            return _a = {}, _a[name] = a, _a;
          });
        };
      };
    }
    exports.bindTo = bindTo8;
    function let_8(F) {
      return function(name, f) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a;
            return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
          });
        };
      };
    }
    exports.let = let_8;
    function getFunctorComposition2(F, G) {
      var _map10 = map11(F, G);
      return {
        map: function(fga, f) {
          return (0, function_1.pipe)(fga, _map10(f));
        }
      };
    }
    exports.getFunctorComposition = getFunctorComposition2;
  }
});

// node_modules/fp-ts/lib/Applicative.js
var require_Applicative = __commonJS({
  "node_modules/fp-ts/lib/Applicative.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;
    var Apply_1 = require_Apply();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function getApplicativeMonoid2(F) {
      var f = (0, Apply_1.getApplySemigroup)(F);
      return function(M) {
        return {
          concat: f(M).concat,
          empty: F.of(M.empty)
        };
      };
    }
    exports.getApplicativeMonoid = getApplicativeMonoid2;
    function getApplicativeComposition(F, G) {
      var map11 = (0, Functor_1.getFunctorComposition)(F, G).map;
      var _ap7 = (0, Apply_1.ap)(F, G);
      return {
        map: map11,
        of: function(a) {
          return F.of(G.of(a));
        },
        ap: function(fgab, fga) {
          return (0, function_1.pipe)(fgab, _ap7(fga));
        }
      };
    }
    exports.getApplicativeComposition = getApplicativeComposition;
  }
});

// node_modules/fp-ts/lib/Chain.js
var require_Chain = __commonJS({
  "node_modules/fp-ts/lib/Chain.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bind = exports.chainFirst = void 0;
    function chainFirst8(M) {
      return function(f) {
        return function(first2) {
          return M.chain(first2, function(a) {
            return M.map(f(a), function() {
              return a;
            });
          });
        };
      };
    }
    exports.chainFirst = chainFirst8;
    function bind8(M) {
      return function(name, f) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return M.map(f(a), function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            });
          });
        };
      };
    }
    exports.bind = bind8;
  }
});

// node_modules/fp-ts/lib/ChainRec.js
var require_ChainRec = __commonJS({
  "node_modules/fp-ts/lib/ChainRec.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tailRec = void 0;
    var tailRec2 = function(startWith, f) {
      var ab = f(startWith);
      while (ab._tag === "Left") {
        ab = f(ab.left);
      }
      return ab.right;
    };
    exports.tailRec = tailRec2;
  }
});

// node_modules/fp-ts/lib/FromEither.js
var require_FromEither = __commonJS({
  "node_modules/fp-ts/lib/FromEither.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function fromOption4(F) {
      return function(onNone) {
        return function(ma) {
          return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
        };
      };
    }
    exports.fromOption = fromOption4;
    function fromPredicate5(F) {
      return function(predicate, onFalse) {
        return function(a) {
          return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
        };
      };
    }
    exports.fromPredicate = fromPredicate5;
    function fromOptionK4(F) {
      var fromOptionF = fromOption4(F);
      return function(onNone) {
        var from = fromOptionF(onNone);
        return function(f) {
          return (0, function_1.flow)(f, from);
        };
      };
    }
    exports.fromOptionK = fromOptionK4;
    function chainOptionK3(F, M) {
      var fromOptionKF = fromOptionK4(F);
      return function(onNone) {
        var from = fromOptionKF(onNone);
        return function(f) {
          return function(ma) {
            return M.chain(ma, from(f));
          };
        };
      };
    }
    exports.chainOptionK = chainOptionK3;
    function fromEitherK5(F) {
      return function(f) {
        return (0, function_1.flow)(f, F.fromEither);
      };
    }
    exports.fromEitherK = fromEitherK5;
    function chainEitherK3(F, M) {
      var fromEitherKF = fromEitherK5(F);
      return function(f) {
        return function(ma) {
          return M.chain(ma, fromEitherKF(f));
        };
      };
    }
    exports.chainEitherK = chainEitherK3;
    function chainFirstEitherK3(F, M) {
      return (0, function_1.flow)(fromEitherK5(F), (0, Chain_1.chainFirst)(M));
    }
    exports.chainFirstEitherK = chainFirstEitherK3;
    function filterOrElse3(F, M) {
      return function(predicate, onFalse) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          });
        };
      };
    }
    exports.filterOrElse = filterOrElse3;
  }
});

// node_modules/fp-ts/lib/Separated.js
var require_Separated = __commonJS({
  "node_modules/fp-ts/lib/Separated.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var separated2 = function(left5, right5) {
      return { left: left5, right: right5 };
    };
    exports.separated = separated2;
    var _map10 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _mapLeft2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _bimap2 = function(fa, g, f) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));
    };
    var map11 = function(f) {
      return function(fa) {
        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
      };
    };
    exports.map = map11;
    var mapLeft3 = function(f) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
      };
    };
    exports.mapLeft = mapLeft3;
    var bimap3 = function(f, g) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
      };
    };
    exports.bimap = bimap3;
    exports.URI = "Separated";
    exports.Bifunctor = {
      URI: exports.URI,
      mapLeft: _mapLeft2,
      bimap: _bimap2
    };
    exports.Functor = {
      URI: exports.URI,
      map: _map10
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    var left4 = function(s) {
      return s.left;
    };
    exports.left = left4;
    var right4 = function(s) {
      return s.right;
    };
    exports.right = right4;
  }
});

// node_modules/fp-ts/lib/Witherable.js
var require_Witherable = __commonJS({
  "node_modules/fp-ts/lib/Witherable.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterE = exports.witherDefault = exports.wiltDefault = void 0;
    var _ = __importStar(require_internal());
    function wiltDefault2(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.separate);
        };
      };
    }
    exports.wiltDefault = wiltDefault2;
    function witherDefault2(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.compact);
        };
      };
    }
    exports.witherDefault = witherDefault2;
    function filterE4(W) {
      return function(F) {
        var witherF = W.wither(F);
        return function(predicate) {
          return function(ga) {
            return witherF(ga, function(a) {
              return F.map(predicate(a), function(b) {
                return b ? _.some(a) : _.none;
              });
            });
          };
        };
      };
    }
    exports.filterE = filterE4;
  }
});

// node_modules/fp-ts/lib/Either.js
var require_Either = __commonJS({
  "node_modules/fp-ts/lib/Either.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.chainW = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.right = exports.left = void 0;
    exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.chainFirstW = exports.chainFirst = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var ChainRec_1 = require_ChainRec();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    exports.left = _.left;
    exports.right = _.right;
    var _map10 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _ap7 = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _chain7 = function(ma, f) {
      return (0, function_1.pipe)(ma, (0, exports.chain)(f));
    };
    var _reduce8 = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
    };
    var _foldMap8 = function(M) {
      return function(fa, f) {
        var foldMapM = (0, exports.foldMap)(M);
        return (0, function_1.pipe)(fa, foldMapM(f));
      };
    };
    var _reduceRight8 = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
    };
    var _traverse8 = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f) {
        return (0, function_1.pipe)(ta, traverseF(f));
      };
    };
    var _bimap2 = function(fa, f, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g));
    };
    var _mapLeft2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _alt5 = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _extend5 = function(wa, f) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f));
    };
    var _chainRec2 = function(a, f) {
      return (0, ChainRec_1.tailRec)(f(a), function(e) {
        return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
      });
    };
    exports.URI = "Either";
    var getShow9 = function(SE, SA) {
      return {
        show: function(ma) {
          return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    exports.getShow = getShow9;
    var getEq9 = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
        }
      };
    };
    exports.getEq = getEq9;
    var getSemigroup6 = function(S) {
      return {
        concat: function(x, y) {
          return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right));
        }
      };
    };
    exports.getSemigroup = getSemigroup6;
    var getCompactable2 = function(M) {
      var empty7 = (0, exports.left)(M.empty);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: function(ma) {
          return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty7 : (0, exports.right)(ma.right.value);
        },
        separate: function(ma) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty7) : (0, Separated_1.separated)(empty7, (0, exports.right)(ma.right.right));
        }
      };
    };
    exports.getCompactable = getCompactable2;
    var getFilterable2 = function(M) {
      var empty7 = (0, exports.left)(M.empty);
      var _a = (0, exports.getCompactable)(M), compact6 = _a.compact, separate6 = _a.separate;
      var filter8 = function(ma, predicate) {
        return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty7;
      };
      var partition7 = function(ma, p) {
        return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p(ma.right) ? (0, Separated_1.separated)(empty7, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty7);
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        compact: compact6,
        separate: separate6,
        filter: filter8,
        filterMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return ma;
          }
          var ob = f(ma.right);
          return ob._tag === "None" ? empty7 : (0, exports.right)(ob.value);
        },
        partition: partition7,
        partitionMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return (0, Separated_1.separated)(ma, ma);
          }
          var e = f(ma.right);
          return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty7) : (0, Separated_1.separated)(empty7, (0, exports.right)(e.right));
        }
      };
    };
    exports.getFilterable = getFilterable2;
    var getWitherable3 = function(M) {
      var F_ = (0, exports.getFilterable)(M);
      var C = (0, exports.getCompactable)(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse8,
        sequence: exports.sequence,
        reduce: _reduce8,
        foldMap: _foldMap8,
        reduceRight: _reduceRight8,
        wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
        wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
      };
    };
    exports.getWitherable = getWitherable3;
    var getApplicativeValidation2 = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        ap: function(fab, fa) {
          return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        },
        of: exports.of
      };
    };
    exports.getApplicativeValidation = getApplicativeValidation2;
    var getAltValidation2 = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        alt: function(me, that) {
          if ((0, exports.isRight)(me)) {
            return me;
          }
          var ea = that();
          return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    exports.getAltValidation = getAltValidation2;
    var map11 = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
      };
    };
    exports.map = map11;
    exports.Functor = {
      URI: exports.URI,
      map: _map10
    };
    exports.of = exports.right;
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    var apW2 = function(fa) {
      return function(fab) {
        return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
      };
    };
    exports.apW = apW2;
    exports.ap = exports.apW;
    exports.Apply = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7
    };
    exports.Applicative = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of
    };
    var chainW2 = function(f) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? ma : f(ma.right);
      };
    };
    exports.chainW = chainW2;
    exports.chain = exports.chainW;
    exports.Chain = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      chain: _chain7
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of,
      chain: _chain7
    };
    var reduce10 = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
      };
    };
    exports.reduce = reduce10;
    var foldMap10 = function(M) {
      return function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
        };
      };
    };
    exports.foldMap = foldMap10;
    var reduceRight10 = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
      };
    };
    exports.reduceRight = reduceRight10;
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8
    };
    var traverse8 = function(F) {
      return function(f) {
        return function(ta) {
          return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
        };
      };
    };
    exports.traverse = traverse8;
    var sequence8 = function(F) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
      };
    };
    exports.sequence = sequence8;
    exports.Traversable = {
      URI: exports.URI,
      map: _map10,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8,
      traverse: _traverse8,
      sequence: exports.sequence
    };
    var bimap3 = function(f, g) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
      };
    };
    exports.bimap = bimap3;
    var mapLeft3 = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
      };
    };
    exports.mapLeft = mapLeft3;
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap2,
      mapLeft: _mapLeft2
    };
    var altW5 = function(that) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? that() : fa;
      };
    };
    exports.altW = altW5;
    exports.alt = exports.altW;
    exports.Alt = {
      URI: exports.URI,
      map: _map10,
      alt: _alt5
    };
    var extend8 = function(f) {
      return function(wa) {
        return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
      };
    };
    exports.extend = extend8;
    exports.Extend = {
      URI: exports.URI,
      map: _map10,
      extend: _extend5
    };
    exports.ChainRec = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      chain: _chain7,
      chainRec: _chainRec2
    };
    exports.throwError = exports.left;
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of,
      chain: _chain7,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: function_1.identity
    };
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.fromOption = (0, FromEither_1.fromOption)(exports.FromEither);
    exports.isLeft = _.isLeft;
    exports.isRight = _.isRight;
    var matchW5 = function(onLeft, onRight) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    exports.matchW = matchW5;
    exports.foldW = exports.matchW;
    exports.match = exports.matchW;
    exports.fold = exports.match;
    var getOrElseW3 = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    exports.getOrElseW = getOrElseW3;
    exports.getOrElse = exports.getOrElseW;
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
    exports.chainFirstW = exports.chainFirst;
    exports.flattenW = (0, exports.chainW)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.fromOptionK = (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    var swap2 = function(ma) {
      return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
    };
    exports.swap = swap2;
    var orElseW2 = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
      };
    };
    exports.orElseW = orElseW2;
    exports.orElse = exports.orElseW;
    var fromNullable3 = function(e) {
      return function(a) {
        return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
      };
    };
    exports.fromNullable = fromNullable3;
    var tryCatch3 = function(f, onThrow) {
      try {
        return (0, exports.right)(f());
      } catch (e) {
        return (0, exports.left)(onThrow(e));
      }
    };
    exports.tryCatch = tryCatch3;
    var tryCatchK3 = function(f, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f.apply(void 0, a);
        }, onThrow);
      };
    };
    exports.tryCatchK = tryCatchK3;
    var fromNullableK3 = function(e) {
      var from = (0, exports.fromNullable)(e);
      return function(f) {
        return (0, function_1.flow)(f, from);
      };
    };
    exports.fromNullableK = fromNullableK3;
    var chainNullableK3 = function(e) {
      var from = (0, exports.fromNullableK)(e);
      return function(f) {
        return (0, exports.chain)(from(f));
      };
    };
    exports.chainNullableK = chainNullableK3;
    exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
    function toError2(e) {
      return e instanceof Error ? e : new Error(String(e));
    }
    exports.toError = toError2;
    function elem7(E) {
      return function(a, ma) {
        if (ma === void 0) {
          var elemE_1 = elem7(E);
          return function(ma2) {
            return elemE_1(a, ma2);
          };
        }
        return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
      };
    }
    exports.elem = elem7;
    var exists4 = function(predicate) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
      };
    };
    exports.exists = exists4;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_8 = (0, Functor_1.let)(exports.Functor);
    exports.let = let_8;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex3 = function(f) {
      return function(as) {
        var e = f(0, _.head(as));
        if ((0, exports.isLeft)(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
          var e_1 = f(i, as[i]);
          if ((0, exports.isLeft)(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return (0, exports.right)(out);
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex3;
    var traverseReadonlyArrayWithIndex3 = function(f) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex3;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray3 = function(f) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f(a);
      });
    };
    exports.traverseArray = traverseArray3;
    exports.sequenceArray = (0, exports.traverseArray)(function_1.identity);
    function parseJSON2(s, onError) {
      return (0, exports.tryCatch)(function() {
        return JSON.parse(s);
      }, onError);
    }
    exports.parseJSON = parseJSON2;
    var stringifyJSON2 = function(u, onError) {
      return (0, exports.tryCatch)(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    exports.stringifyJSON = stringifyJSON2;
    exports.either = {
      URI: exports.URI,
      map: _map10,
      of: exports.of,
      ap: _ap7,
      chain: _chain7,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8,
      traverse: _traverse8,
      sequence: exports.sequence,
      bimap: _bimap2,
      mapLeft: _mapLeft2,
      alt: _alt5,
      extend: _extend5,
      chainRec: _chainRec2,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
    var getValidationSemigroup2 = function(SE, SA) {
      return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
    };
    exports.getValidationSemigroup = getValidationSemigroup2;
    var getValidationMonoid2 = function(SE, MA) {
      return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
    };
    exports.getValidationMonoid = getValidationMonoid2;
    function getValidation2(SE) {
      var ap9 = (0, exports.getApplicativeValidation)(SE).ap;
      var alt6 = (0, exports.getAltValidation)(SE).alt;
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        of: exports.of,
        chain: _chain7,
        bimap: _bimap2,
        mapLeft: _mapLeft2,
        reduce: _reduce8,
        foldMap: _foldMap8,
        reduceRight: _reduceRight8,
        extend: _extend5,
        traverse: _traverse8,
        sequence: exports.sequence,
        chainRec: _chainRec2,
        throwError: exports.throwError,
        ap: ap9,
        alt: alt6
      };
    }
    exports.getValidation = getValidation2;
  }
});

// node_modules/fp-ts/es6/Eq.js
var fromEquals, eqStrict, strictEqual;
var init_Eq = __esm({
  "node_modules/fp-ts/es6/Eq.js"() {
    init_shim();
    init_function();
    fromEquals = function(equals) {
      return {
        equals: function(x, y) {
          return x === y || equals(x, y);
        }
      };
    };
    eqStrict = {
      equals: function(a, b) {
        return a === b;
      }
    };
    strictEqual = eqStrict.equals;
  }
});

// node_modules/fp-ts/es6/Ord.js
function compare(first2, second) {
  return first2 < second ? -1 : first2 > second ? 1 : 0;
}
var equalsDefault, fromCompare, contramap, getSemigroup2, getMonoid, trivial, min, max, strictOrd, ordNumber, ordDate;
var init_Ord = __esm({
  "node_modules/fp-ts/es6/Ord.js"() {
    init_shim();
    init_Eq();
    init_function();
    equalsDefault = function(compare2) {
      return function(first2, second) {
        return first2 === second || compare2(first2, second) === 0;
      };
    };
    fromCompare = function(compare2) {
      return {
        equals: equalsDefault(compare2),
        compare: function(first2, second) {
          return first2 === second ? 0 : compare2(first2, second);
        }
      };
    };
    contramap = function(f) {
      return function(fa) {
        return fromCompare(function(first2, second) {
          return fa.compare(f(first2), f(second));
        });
      };
    };
    getSemigroup2 = function() {
      return {
        concat: function(first2, second) {
          return fromCompare(function(a, b) {
            var ox = first2.compare(a, b);
            return ox !== 0 ? ox : second.compare(a, b);
          });
        }
      };
    };
    getMonoid = function() {
      return {
        concat: getSemigroup2().concat,
        empty: fromCompare(function() {
          return 0;
        })
      };
    };
    trivial = {
      equals: constTrue,
      compare: constant(0)
    };
    min = function(O) {
      return function(first2, second) {
        return first2 === second || O.compare(first2, second) < 1 ? first2 : second;
      };
    };
    max = function(O) {
      return function(first2, second) {
        return first2 === second || O.compare(first2, second) > -1 ? first2 : second;
      };
    };
    strictOrd = {
      equals: eqStrict.equals,
      compare
    };
    ordNumber = strictOrd;
    ordDate = pipe(
      ordNumber,
      contramap(function(date) {
        return date.valueOf();
      })
    );
  }
});

// node_modules/fp-ts/es6/Magma.js
var init_Magma = __esm({
  "node_modules/fp-ts/es6/Magma.js"() {
    init_shim();
  }
});

// node_modules/fp-ts/es6/Semigroup.js
var min2, max2, constant2, first, last, semigroupVoid;
var init_Semigroup = __esm({
  "node_modules/fp-ts/es6/Semigroup.js"() {
    init_shim();
    init_function();
    init_internal();
    init_Magma();
    init_Ord();
    min2 = function(O) {
      return {
        concat: min(O)
      };
    };
    max2 = function(O) {
      return {
        concat: max(O)
      };
    };
    constant2 = function(a) {
      return {
        concat: function() {
          return a;
        }
      };
    };
    first = function() {
      return { concat: identity };
    };
    last = function() {
      return { concat: function(_, y) {
        return y;
      } };
    };
    semigroupVoid = constant2(void 0);
  }
});

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray3, empty, isNonEmpty3, isOutOfBound, prependW, prepend, appendW, append, prependAll, intersperse, chainWithIndex, _map3, _ap2, _chain2, of2, ap3, chain2, extend2, duplicate2, flatten2, map3, mapWithIndex, reduce2, foldMap2, reduceRight2, reduceWithIndex, foldMapWithIndex, reduceRightWithIndex, extract, URI3, getShow2, getEq2, Functor3, flap4, Apply2, apFirst3, apSecond3, Chain2, chainFirst3, Do2, bindTo3, let_3, bind3, apS3, head2, tail2, last2, min3, max3, concatAll2, intercalate;
var init_ReadonlyNonEmptyArray = __esm({
  "node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_Eq();
    init_function();
    init_Functor();
    init_internal();
    init_Ord();
    init_Semigroup();
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    empty = emptyReadonlyArray;
    isNonEmpty3 = isNonEmpty;
    isOutOfBound = function(i, as) {
      return i < 0 || i >= as.length;
    };
    prependW = function(head6) {
      return function(tail5) {
        return __spreadArray3([head6], tail5, true);
      };
    };
    prepend = prependW;
    appendW = function(end) {
      return function(init4) {
        return __spreadArray3(__spreadArray3([], init4, true), [end], false);
      };
    };
    append = appendW;
    prependAll = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    intersperse = function(middle) {
      return function(as) {
        var rest = tail2(as);
        return isNonEmpty3(rest) ? pipe(rest, prependAll(middle), prepend(head2(as))) : as;
      };
    };
    chainWithIndex = function(f) {
      return function(as) {
        var out = fromReadonlyNonEmptyArray(f(0, head2(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    _map3 = function(fa, f) {
      return pipe(fa, map3(f));
    };
    _ap2 = function(fab, fa) {
      return pipe(fab, ap3(fa));
    };
    _chain2 = function(ma, f) {
      return pipe(ma, chain2(f));
    };
    of2 = singleton;
    ap3 = function(as) {
      return chain2(function(f) {
        return pipe(as, map3(f));
      });
    };
    chain2 = function(f) {
      return chainWithIndex(function(_, a) {
        return f(a);
      });
    };
    extend2 = function(f) {
      return function(as) {
        var next = tail2(as);
        var out = [f(as)];
        while (isNonEmpty3(next)) {
          out.push(f(next));
          next = tail2(next);
        }
        return out;
      };
    };
    duplicate2 = extend2(identity);
    flatten2 = chain2(identity);
    map3 = function(f) {
      return mapWithIndex(function(_, a) {
        return f(a);
      });
    };
    mapWithIndex = function(f) {
      return function(as) {
        var out = [f(0, head2(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f(i, as[i]));
        }
        return out;
      };
    };
    reduce2 = function(b, f) {
      return reduceWithIndex(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    foldMap2 = function(S) {
      return function(f) {
        return function(as) {
          return as.slice(1).reduce(function(s, a) {
            return S.concat(s, f(a));
          }, f(as[0]));
        };
      };
    };
    reduceRight2 = function(b, f) {
      return reduceRightWithIndex(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    reduceWithIndex = function(b, f) {
      return function(as) {
        return as.reduce(function(b2, a, i) {
          return f(i, b2, a);
        }, b);
      };
    };
    foldMapWithIndex = function(S) {
      return function(f) {
        return function(as) {
          return as.slice(1).reduce(function(s, a, i) {
            return S.concat(s, f(i + 1, a));
          }, f(0, as[0]));
        };
      };
    };
    reduceRightWithIndex = function(b, f) {
      return function(as) {
        return as.reduceRight(function(b2, a, i) {
          return f(i, a, b2);
        }, b);
      };
    };
    extract = head;
    URI3 = "ReadonlyNonEmptyArray";
    getShow2 = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    getEq2 = function(E) {
      return fromEquals(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    Functor3 = {
      URI: URI3,
      map: _map3
    };
    flap4 = flap(Functor3);
    Apply2 = {
      URI: URI3,
      map: _map3,
      ap: _ap2
    };
    apFirst3 = apFirst(Apply2);
    apSecond3 = apSecond(Apply2);
    Chain2 = {
      URI: URI3,
      map: _map3,
      ap: _ap2,
      chain: _chain2
    };
    chainFirst3 = chainFirst(Chain2);
    Do2 = of2(emptyRecord);
    bindTo3 = bindTo(Functor3);
    let_3 = let_(Functor3);
    bind3 = bind(Chain2);
    apS3 = apS(Apply2);
    head2 = extract;
    tail2 = tail;
    last2 = function(as) {
      return as[as.length - 1];
    };
    min3 = function(O) {
      var S = min2(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    max3 = function(O) {
      var S = max2(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    concatAll2 = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    intercalate = function(S) {
      var concatAllS = concatAll2(S);
      return function(middle) {
        return flow(intersperse(middle), concatAllS);
      };
    };
  }
});

// node_modules/fp-ts/es6/NonEmptyArray.js
var NonEmptyArray_exports = {};
__export(NonEmptyArray_exports, {
  Alt: () => Alt2,
  Applicative: () => Applicative2,
  Apply: () => Apply3,
  Chain: () => Chain3,
  Comonad: () => Comonad,
  Do: () => Do3,
  Foldable: () => Foldable2,
  FoldableWithIndex: () => FoldableWithIndex,
  Functor: () => Functor4,
  FunctorWithIndex: () => FunctorWithIndex,
  Monad: () => Monad2,
  Pointed: () => Pointed2,
  Traversable: () => Traversable2,
  TraversableWithIndex: () => TraversableWithIndex,
  URI: () => URI4,
  alt: () => alt2,
  altW: () => altW2,
  ap: () => ap4,
  apFirst: () => apFirst4,
  apS: () => apS4,
  apSecond: () => apSecond4,
  append: () => append2,
  appendW: () => appendW2,
  bind: () => bind4,
  bindTo: () => bindTo4,
  chain: () => chain3,
  chainFirst: () => chainFirst4,
  chainWithIndex: () => chainWithIndex2,
  chop: () => chop,
  chunksOf: () => chunksOf,
  concat: () => concat,
  concatAll: () => concatAll3,
  concatW: () => concatW,
  cons: () => cons,
  copy: () => copy,
  duplicate: () => duplicate3,
  extend: () => extend3,
  extract: () => extract2,
  filter: () => filter,
  filterWithIndex: () => filterWithIndex,
  flap: () => flap5,
  flatten: () => flatten3,
  fold: () => fold2,
  foldMap: () => foldMap3,
  foldMapWithIndex: () => foldMapWithIndex2,
  fromArray: () => fromArray,
  fromReadonlyNonEmptyArray: () => fromReadonlyNonEmptyArray2,
  getEq: () => getEq3,
  getSemigroup: () => getSemigroup4,
  getShow: () => getShow3,
  getUnionSemigroup: () => getUnionSemigroup,
  group: () => group,
  groupBy: () => groupBy,
  groupSort: () => groupSort,
  head: () => head3,
  init: () => init,
  insertAt: () => insertAt,
  intercalate: () => intercalate2,
  intersperse: () => intersperse2,
  isNonEmpty: () => isNonEmpty4,
  isOutOfBound: () => isOutOfBound2,
  last: () => last3,
  let: () => let_4,
  makeBy: () => makeBy,
  map: () => map4,
  mapWithIndex: () => mapWithIndex2,
  matchLeft: () => matchLeft,
  matchRight: () => matchRight,
  max: () => max4,
  min: () => min4,
  modifyAt: () => modifyAt,
  modifyHead: () => modifyHead,
  modifyLast: () => modifyLast,
  nonEmptyArray: () => nonEmptyArray,
  of: () => of3,
  prepend: () => prepend2,
  prependAll: () => prependAll2,
  prependToAll: () => prependToAll,
  prependW: () => prependW2,
  range: () => range,
  reduce: () => reduce3,
  reduceRight: () => reduceRight3,
  reduceRightWithIndex: () => reduceRightWithIndex2,
  reduceWithIndex: () => reduceWithIndex2,
  replicate: () => replicate,
  reverse: () => reverse2,
  rotate: () => rotate,
  sequence: () => sequence2,
  snoc: () => snoc,
  sort: () => sort,
  sortBy: () => sortBy,
  splitAt: () => splitAt,
  tail: () => tail3,
  traverse: () => traverse2,
  traverseWithIndex: () => traverseWithIndex,
  unappend: () => unappend,
  uncons: () => uncons,
  union: () => union2,
  uniq: () => uniq,
  unprepend: () => unprepend,
  unsafeInsertAt: () => unsafeInsertAt,
  unsafeUpdateAt: () => unsafeUpdateAt,
  unsnoc: () => unsnoc,
  unzip: () => unzip,
  updateAt: () => updateAt,
  updateHead: () => updateHead,
  updateLast: () => updateLast,
  zip: () => zip,
  zipWith: () => zipWith
});
function concatW(second) {
  return function(first2) {
    return first2.concat(second);
  };
}
function concat(x, y) {
  return y ? x.concat(y) : function(y2) {
    return y2.concat(x);
  };
}
function group(E) {
  return function(as) {
    var len = as.length;
    if (len === 0) {
      return [];
    }
    var out = [];
    var head6 = as[0];
    var nea = [head6];
    for (var i = 1; i < len; i++) {
      var a = as[i];
      if (E.equals(a, head6)) {
        nea.push(a);
      } else {
        out.push(nea);
        head6 = a;
        nea = [head6];
      }
    }
    out.push(nea);
    return out;
  };
}
function zip(as, bs) {
  if (bs === void 0) {
    return function(bs2) {
      return zip(bs2, as);
    };
  }
  return zipWith(as, bs, function(a, b) {
    return [a, b];
  });
}
function groupSort(O) {
  var sortO = sort(O);
  var groupO = group(O);
  return function(as) {
    return isNonEmpty4(as) ? groupO(sortO(as)) : [];
  };
}
function filter(predicate) {
  return filterWithIndex(function(_, a) {
    return predicate(a);
  });
}
function cons(head6, tail5) {
  return tail5 === void 0 ? prepend2(head6) : pipe(tail5, prepend2(head6));
}
var __spreadArray4, isNonEmpty4, isOutOfBound2, prependW2, prepend2, appendW2, append2, unsafeInsertAt, unsafeUpdateAt, uniq, sortBy, union2, rotate, fromReadonlyNonEmptyArray2, fromArray, makeBy, replicate, range, unprepend, unappend, reverse2, groupBy, sort, insertAt, updateAt, modifyAt, copy, of3, zipWith, unzip, prependAll2, intersperse2, foldMapWithIndex2, foldMap3, chainWithIndex2, chop, splitAt, chunksOf, _map4, _mapWithIndex, _ap3, _chain3, _extend2, _reduce2, _foldMap2, _reduceRight2, _traverse2, _alt2, _reduceWithIndex, _foldMapWithIndex, _reduceRightWithIndex, _traverseWithIndex, altW2, alt2, ap4, chain3, extend3, duplicate3, flatten3, map4, mapWithIndex2, reduce3, reduceWithIndex2, reduceRight3, reduceRightWithIndex2, traverse2, sequence2, traverseWithIndex, extract2, URI4, getShow3, getSemigroup4, getEq3, getUnionSemigroup, Functor4, flap5, Pointed2, FunctorWithIndex, Apply3, apFirst4, apSecond4, Applicative2, Chain3, chainFirst4, Monad2, Foldable2, FoldableWithIndex, Traversable2, TraversableWithIndex, Alt2, Comonad, Do3, bindTo4, let_4, bind4, apS4, head3, tail3, last3, init, min4, max4, concatAll3, matchLeft, matchRight, modifyHead, updateHead, modifyLast, updateLast, intercalate2, filterWithIndex, uncons, unsnoc, snoc, prependToAll, fold2, nonEmptyArray;
var init_NonEmptyArray = __esm({
  "node_modules/fp-ts/es6/NonEmptyArray.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_function();
    init_Functor();
    init_internal();
    init_Ord();
    init_ReadonlyNonEmptyArray();
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isNonEmpty4 = function(as) {
      return as.length > 0;
    };
    isOutOfBound2 = function(i, as) {
      return i < 0 || i >= as.length;
    };
    prependW2 = function(head6) {
      return function(tail5) {
        return __spreadArray4([head6], tail5, true);
      };
    };
    prepend2 = prependW2;
    appendW2 = function(end) {
      return function(init4) {
        return __spreadArray4(__spreadArray4([], init4, true), [end], false);
      };
    };
    append2 = appendW2;
    unsafeInsertAt = function(i, a, as) {
      if (isNonEmpty4(as)) {
        var xs = fromReadonlyNonEmptyArray2(as);
        xs.splice(i, 0, a);
        return xs;
      }
      return [a];
    };
    unsafeUpdateAt = function(i, a, as) {
      var xs = fromReadonlyNonEmptyArray2(as);
      xs[i] = a;
      return xs;
    };
    uniq = function(E) {
      return function(as) {
        if (as.length === 1) {
          return copy(as);
        }
        var out = [head3(as)];
        var rest = tail3(as);
        var _loop_1 = function(a2) {
          if (out.every(function(o) {
            return !E.equals(o, a2);
          })) {
            out.push(a2);
          }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
          var a = rest_1[_i];
          _loop_1(a);
        }
        return out;
      };
    };
    sortBy = function(ords) {
      if (isNonEmpty4(ords)) {
        var M = getMonoid();
        return sort(ords.reduce(M.concat, M.empty));
      }
      return copy;
    };
    union2 = function(E) {
      var uniqE = uniq(E);
      return function(second) {
        return function(first2) {
          return uniqE(pipe(first2, concat(second)));
        };
      };
    };
    rotate = function(n) {
      return function(as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if (isOutOfBound2(Math.abs(m), as) || m === 0) {
          return copy(as);
        }
        if (m < 0) {
          var _a = splitAt(-m)(as), f = _a[0], s = _a[1];
          return pipe(s, concat(f));
        } else {
          return rotate(m - len)(as);
        }
      };
    };
    fromReadonlyNonEmptyArray2 = fromReadonlyNonEmptyArray;
    fromArray = function(as) {
      return isNonEmpty4(as) ? some(as) : none;
    };
    makeBy = function(f) {
      return function(n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f(0)];
        for (var i = 1; i < j; i++) {
          out.push(f(i));
        }
        return out;
      };
    };
    replicate = function(a) {
      return makeBy(function() {
        return a;
      });
    };
    range = function(start, end) {
      return start <= end ? makeBy(function(i) {
        return start + i;
      })(end - start + 1) : [start];
    };
    unprepend = function(as) {
      return [head3(as), tail3(as)];
    };
    unappend = function(as) {
      return [init(as), last3(as)];
    };
    reverse2 = function(as) {
      return __spreadArray4([last3(as)], as.slice(0, -1).reverse(), true);
    };
    groupBy = function(f) {
      return function(as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
          var a = as_1[_i];
          var k = f(a);
          if (has.call(out, k)) {
            out[k].push(a);
          } else {
            out[k] = [a];
          }
        }
        return out;
      };
    };
    sort = function(O) {
      return function(as) {
        return as.slice().sort(O.compare);
      };
    };
    insertAt = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? none : some(unsafeInsertAt(i, a, as));
      };
    };
    updateAt = function(i, a) {
      return modifyAt(i, function() {
        return a;
      });
    };
    modifyAt = function(i, f) {
      return function(as) {
        return isOutOfBound2(i, as) ? none : some(unsafeUpdateAt(i, f(as[i]), as));
      };
    };
    copy = fromReadonlyNonEmptyArray2;
    of3 = function(a) {
      return [a];
    };
    zipWith = function(as, bs, f) {
      var cs = [f(as[0], bs[0])];
      var len = Math.min(as.length, bs.length);
      for (var i = 1; i < len; i++) {
        cs[i] = f(as[i], bs[i]);
      }
      return cs;
    };
    unzip = function(abs) {
      var fa = [abs[0][0]];
      var fb = [abs[0][1]];
      for (var i = 1; i < abs.length; i++) {
        fa[i] = abs[i][0];
        fb[i] = abs[i][1];
      }
      return [fa, fb];
    };
    prependAll2 = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    intersperse2 = function(middle) {
      return function(as) {
        var rest = tail3(as);
        return isNonEmpty4(rest) ? pipe(rest, prependAll2(middle), prepend2(head3(as))) : copy(as);
      };
    };
    foldMapWithIndex2 = foldMapWithIndex;
    foldMap3 = foldMap2;
    chainWithIndex2 = function(f) {
      return function(as) {
        var out = fromReadonlyNonEmptyArray2(f(0, head3(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    chop = function(f) {
      return function(as) {
        var _a = f(as), b = _a[0], rest = _a[1];
        var out = [b];
        var next = rest;
        while (isNonEmpty4(next)) {
          var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
          out.push(b_1);
          next = rest_2;
        }
        return out;
      };
    };
    splitAt = function(n) {
      return function(as) {
        var m = Math.max(1, n);
        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend2(head3(as))), as.slice(m)];
      };
    };
    chunksOf = function(n) {
      return chop(splitAt(n));
    };
    _map4 = function(fa, f) {
      return pipe(fa, map4(f));
    };
    _mapWithIndex = function(fa, f) {
      return pipe(fa, mapWithIndex2(f));
    };
    _ap3 = function(fab, fa) {
      return pipe(fab, ap4(fa));
    };
    _chain3 = function(ma, f) {
      return pipe(ma, chain3(f));
    };
    _extend2 = function(wa, f) {
      return pipe(wa, extend3(f));
    };
    _reduce2 = function(fa, b, f) {
      return pipe(fa, reduce3(b, f));
    };
    _foldMap2 = function(M) {
      var foldMapM = foldMap3(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight2 = function(fa, b, f) {
      return pipe(fa, reduceRight3(b, f));
    };
    _traverse2 = function(F) {
      var traverseF = traverse2(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _alt2 = function(fa, that) {
      return pipe(fa, alt2(that));
    };
    _reduceWithIndex = function(fa, b, f) {
      return pipe(fa, reduceWithIndex2(b, f));
    };
    _foldMapWithIndex = function(M) {
      var foldMapWithIndexM = foldMapWithIndex2(M);
      return function(fa, f) {
        return pipe(fa, foldMapWithIndexM(f));
      };
    };
    _reduceRightWithIndex = function(fa, b, f) {
      return pipe(fa, reduceRightWithIndex2(b, f));
    };
    _traverseWithIndex = function(F) {
      var traverseWithIndexF = traverseWithIndex(F);
      return function(ta, f) {
        return pipe(ta, traverseWithIndexF(f));
      };
    };
    altW2 = function(that) {
      return function(as) {
        return pipe(as, concatW(that()));
      };
    };
    alt2 = altW2;
    ap4 = function(as) {
      return chain3(function(f) {
        return pipe(as, map4(f));
      });
    };
    chain3 = function(f) {
      return chainWithIndex2(function(_, a) {
        return f(a);
      });
    };
    extend3 = function(f) {
      return function(as) {
        var next = tail3(as);
        var out = [f(as)];
        while (isNonEmpty4(next)) {
          out.push(f(next));
          next = tail3(next);
        }
        return out;
      };
    };
    duplicate3 = extend3(identity);
    flatten3 = chain3(identity);
    map4 = function(f) {
      return mapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    mapWithIndex2 = function(f) {
      return function(as) {
        var out = [f(0, head3(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f(i, as[i]));
        }
        return out;
      };
    };
    reduce3 = reduce2;
    reduceWithIndex2 = reduceWithIndex;
    reduceRight3 = reduceRight2;
    reduceRightWithIndex2 = reduceRightWithIndex;
    traverse2 = function(F) {
      var traverseWithIndexF = traverseWithIndex(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence2 = function(F) {
      return traverseWithIndex(F)(function(_, a) {
        return a;
      });
    };
    traverseWithIndex = function(F) {
      return function(f) {
        return function(as) {
          var out = F.map(f(0, head3(as)), of3);
          for (var i = 1; i < as.length; i++) {
            out = F.ap(F.map(out, function(bs) {
              return function(b) {
                return pipe(bs, append2(b));
              };
            }), f(i, as[i]));
          }
          return out;
        };
      };
    };
    extract2 = head2;
    URI4 = "NonEmptyArray";
    getShow3 = getShow2;
    getSemigroup4 = function() {
      return {
        concat
      };
    };
    getEq3 = getEq2;
    getUnionSemigroup = function(E) {
      var unionE = union2(E);
      return {
        concat: function(first2, second) {
          return unionE(second)(first2);
        }
      };
    };
    Functor4 = {
      URI: URI4,
      map: _map4
    };
    flap5 = flap(Functor4);
    Pointed2 = {
      URI: URI4,
      of: of3
    };
    FunctorWithIndex = {
      URI: URI4,
      map: _map4,
      mapWithIndex: _mapWithIndex
    };
    Apply3 = {
      URI: URI4,
      map: _map4,
      ap: _ap3
    };
    apFirst4 = apFirst(Apply3);
    apSecond4 = apSecond(Apply3);
    Applicative2 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      of: of3
    };
    Chain3 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      chain: _chain3
    };
    chainFirst4 = chainFirst(Chain3);
    Monad2 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      of: of3,
      chain: _chain3
    };
    Foldable2 = {
      URI: URI4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2
    };
    FoldableWithIndex = {
      URI: URI4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex
    };
    Traversable2 = {
      URI: URI4,
      map: _map4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2
    };
    TraversableWithIndex = {
      URI: URI4,
      map: _map4,
      mapWithIndex: _mapWithIndex,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex
    };
    Alt2 = {
      URI: URI4,
      map: _map4,
      alt: _alt2
    };
    Comonad = {
      URI: URI4,
      map: _map4,
      extend: _extend2,
      extract: extract2
    };
    Do3 = of3(emptyRecord);
    bindTo4 = bindTo(Functor4);
    let_4 = let_(Functor4);
    bind4 = bind(Chain3);
    apS4 = apS(Apply3);
    head3 = head2;
    tail3 = function(as) {
      return as.slice(1);
    };
    last3 = last2;
    init = function(as) {
      return as.slice(0, -1);
    };
    min4 = min3;
    max4 = max3;
    concatAll3 = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    matchLeft = function(f) {
      return function(as) {
        return f(head3(as), tail3(as));
      };
    };
    matchRight = function(f) {
      return function(as) {
        return f(init(as), last3(as));
      };
    };
    modifyHead = function(f) {
      return function(as) {
        return __spreadArray4([f(head3(as))], tail3(as), true);
      };
    };
    updateHead = function(a) {
      return modifyHead(function() {
        return a;
      });
    };
    modifyLast = function(f) {
      return function(as) {
        return pipe(init(as), append2(f(last3(as))));
      };
    };
    updateLast = function(a) {
      return modifyLast(function() {
        return a;
      });
    };
    intercalate2 = intercalate;
    filterWithIndex = function(predicate) {
      return function(as) {
        return fromArray(as.filter(function(a, i) {
          return predicate(i, a);
        }));
      };
    };
    uncons = unprepend;
    unsnoc = unappend;
    snoc = function(init4, end) {
      return pipe(init4, append2(end));
    };
    prependToAll = prependAll2;
    fold2 = concatAll2;
    nonEmptyArray = {
      URI: URI4,
      of: of3,
      map: _map4,
      mapWithIndex: _mapWithIndex,
      ap: _ap3,
      chain: _chain3,
      extend: _extend2,
      extract: extract2,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex,
      alt: _alt2
    };
  }
});

// node_modules/fp-ts/es6/number.js
var Eq, Ord, Bounded, MagmaSub, SemigroupSum, SemigroupProduct, MonoidSum, MonoidProduct, Field;
var init_number = __esm({
  "node_modules/fp-ts/es6/number.js"() {
    init_shim();
    Eq = {
      equals: function(first2, second) {
        return first2 === second;
      }
    };
    Ord = {
      equals: Eq.equals,
      compare: function(first2, second) {
        return first2 < second ? -1 : first2 > second ? 1 : 0;
      }
    };
    Bounded = {
      equals: Eq.equals,
      compare: Ord.compare,
      top: Infinity,
      bottom: -Infinity
    };
    MagmaSub = {
      concat: function(first2, second) {
        return first2 - second;
      }
    };
    SemigroupSum = {
      concat: function(first2, second) {
        return first2 + second;
      }
    };
    SemigroupProduct = {
      concat: function(first2, second) {
        return first2 * second;
      }
    };
    MonoidSum = {
      concat: SemigroupSum.concat,
      empty: 0
    };
    MonoidProduct = {
      concat: SemigroupProduct.concat,
      empty: 1
    };
    Field = {
      add: SemigroupSum.concat,
      zero: 0,
      mul: SemigroupProduct.concat,
      one: 1,
      sub: MagmaSub.concat,
      degree: function(_) {
        return 1;
      },
      div: function(first2, second) {
        return first2 / second;
      },
      mod: function(first2, second) {
        return first2 % second;
      }
    };
  }
});

// node_modules/fp-ts/es6/Zero.js
function guard(F, P) {
  return function(b) {
    return b ? P.of(void 0) : F.zero();
  };
}
var init_Zero = __esm({
  "node_modules/fp-ts/es6/Zero.js"() {
    init_shim();
  }
});

// node_modules/fp-ts/es6/ReadonlyArray.js
function lookup(i, as) {
  return as === void 0 ? function(as2) {
    return lookup(i, as2);
  } : isOutOfBound3(i, as) ? none : some(as[i]);
}
function findFirst(predicate) {
  return function(as) {
    for (var i = 0; i < as.length; i++) {
      if (predicate(as[i])) {
        return some(as[i]);
      }
    }
    return none;
  };
}
function findLast(predicate) {
  return function(as) {
    for (var i = as.length - 1; i >= 0; i--) {
      if (predicate(as[i])) {
        return some(as[i]);
      }
    }
    return none;
  };
}
function elem2(E) {
  return function(a, as) {
    if (as === void 0) {
      var elemE_1 = elem2(E);
      return function(as2) {
        return elemE_1(a, as2);
      };
    }
    var predicate = function(element) {
      return E.equals(element, a);
    };
    var i = 0;
    for (; i < as.length; i++) {
      if (predicate(as[i])) {
        return true;
      }
    }
    return false;
  };
}
function every(predicate) {
  return function(as) {
    return as.every(predicate);
  };
}
var __spreadArray5, isEmpty, isNonEmpty5, append3, fromEither, matchW2, match2, chainWithIndex3, isOutOfBound3, head4, last4, findIndex, findFirstMap, findLastMap, findLastIndex, _map5, _ap4, _chain4, _filter, _filterMap, _partition, _partitionMap, _reduce3, _foldMap3, _reduceRight3, _traverse3, _chainRecDepthFirst, _chainRecBreadthFirst, of4, zero, ap5, chain4, flatten4, map5, separate, filter2, filterMapWithIndex, filterMap, compact, partition, partitionWithIndex, partitionMap, partitionMapWithIndex, extend4, duplicate4, foldMapWithIndex3, reduce4, foldMap4, reduceWithIndex3, reduceRight4, reduceRightWithIndex3, traverse3, sequence3, traverseWithIndex2, URI5, getShow4, getEq4, getOrd, Functor5, flap6, Pointed3, Apply4, apFirst5, apSecond5, Chain4, chainFirst5, Zero, guard2, Compactable, Traversable3, chainRecDepthFirst, chainRecBreadthFirst, _wither, _wilt, Witherable, filterE2, FromEither2, fromEitherK2, empty2, intercalate3, Do4, bindTo5, let_5, bind5, apS5;
var init_ReadonlyArray = __esm({
  "node_modules/fp-ts/es6/ReadonlyArray.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_Eq();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_number();
    init_Ord();
    init_ReadonlyNonEmptyArray();
    init_Separated();
    init_Witherable();
    init_Zero();
    __spreadArray5 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isEmpty = function(as) {
      return as.length === 0;
    };
    isNonEmpty5 = isNonEmpty3;
    append3 = append;
    fromEither = function(e) {
      return isLeft(e) ? empty2 : [e.right];
    };
    matchW2 = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty5(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    match2 = matchW2;
    chainWithIndex3 = function(f) {
      return function(as) {
        if (isEmpty(as)) {
          return empty2;
        }
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    isOutOfBound3 = isOutOfBound;
    head4 = function(as) {
      return isNonEmpty5(as) ? some(head2(as)) : none;
    };
    last4 = function(as) {
      return isNonEmpty5(as) ? some(last2(as)) : none;
    };
    findIndex = function(predicate) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          if (predicate(as[i])) {
            return some(i);
          }
        }
        return none;
      };
    };
    findFirstMap = function(f) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          var out = f(as[i]);
          if (isSome(out)) {
            return out;
          }
        }
        return none;
      };
    };
    findLastMap = function(f) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          var out = f(as[i]);
          if (isSome(out)) {
            return out;
          }
        }
        return none;
      };
    };
    findLastIndex = function(predicate) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          if (predicate(as[i])) {
            return some(i);
          }
        }
        return none;
      };
    };
    _map5 = function(fa, f) {
      return pipe(fa, map5(f));
    };
    _ap4 = function(fab, fa) {
      return pipe(fab, ap5(fa));
    };
    _chain4 = function(ma, f) {
      return pipe(ma, chain4(f));
    };
    _filter = function(fa, predicate) {
      return pipe(fa, filter2(predicate));
    };
    _filterMap = function(fa, f) {
      return pipe(fa, filterMap(f));
    };
    _partition = function(fa, predicate) {
      return pipe(fa, partition(predicate));
    };
    _partitionMap = function(fa, f) {
      return pipe(fa, partitionMap(f));
    };
    _reduce3 = function(fa, b, f) {
      return pipe(fa, reduce4(b, f));
    };
    _foldMap3 = function(M) {
      var foldMapM = foldMap4(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight3 = function(fa, b, f) {
      return pipe(fa, reduceRight4(b, f));
    };
    _traverse3 = function(F) {
      var traverseF = traverse3(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _chainRecDepthFirst = function(a, f) {
      return pipe(a, chainRecDepthFirst(f));
    };
    _chainRecBreadthFirst = function(a, f) {
      return pipe(a, chainRecBreadthFirst(f));
    };
    of4 = of2;
    zero = function() {
      return empty2;
    };
    ap5 = function(fa) {
      return chain4(function(f) {
        return pipe(fa, map5(f));
      });
    };
    chain4 = function(f) {
      return function(ma) {
        return pipe(ma, chainWithIndex3(function(_, a) {
          return f(a);
        }));
      };
    };
    flatten4 = chain4(identity);
    map5 = function(f) {
      return function(fa) {
        return fa.map(function(a) {
          return f(a);
        });
      };
    };
    separate = function(fa) {
      var left4 = [];
      var right4 = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left4.push(e.left);
        } else {
          right4.push(e.right);
        }
      }
      return separated(left4, right4);
    };
    filter2 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    filterMapWithIndex = function(f) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f(i, fa[i]);
          if (isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    filterMap = function(f) {
      return filterMapWithIndex(function(_, a) {
        return f(a);
      });
    };
    compact = filterMap(identity);
    partition = function(predicate) {
      return partitionWithIndex(function(_, a) {
        return predicate(a);
      });
    };
    partitionWithIndex = function(predicateWithIndex) {
      return function(as) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (predicateWithIndex(i, a)) {
            right4.push(a);
          } else {
            left4.push(a);
          }
        }
        return separated(left4, right4);
      };
    };
    partitionMap = function(f) {
      return partitionMapWithIndex(function(_, a) {
        return f(a);
      });
    };
    partitionMapWithIndex = function(f) {
      return function(fa) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f(i, fa[i]);
          if (e._tag === "Left") {
            left4.push(e.left);
          } else {
            right4.push(e.right);
          }
        }
        return separated(left4, right4);
      };
    };
    extend4 = function(f) {
      return function(wa) {
        return wa.map(function(_, i) {
          return f(wa.slice(i));
        });
      };
    };
    duplicate4 = extend4(identity);
    foldMapWithIndex3 = function(M) {
      return function(f) {
        return function(fa) {
          return fa.reduce(function(b, a, i) {
            return M.concat(b, f(i, a));
          }, M.empty);
        };
      };
    };
    reduce4 = function(b, f) {
      return reduceWithIndex3(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    foldMap4 = function(M) {
      var foldMapWithIndexM = foldMapWithIndex3(M);
      return function(f) {
        return foldMapWithIndexM(function(_, a) {
          return f(a);
        });
      };
    };
    reduceWithIndex3 = function(b, f) {
      return function(fa) {
        var len = fa.length;
        var out = b;
        for (var i = 0; i < len; i++) {
          out = f(i, out, fa[i]);
        }
        return out;
      };
    };
    reduceRight4 = function(b, f) {
      return reduceRightWithIndex3(b, function(_, a, b2) {
        return f(a, b2);
      });
    };
    reduceRightWithIndex3 = function(b, f) {
      return function(fa) {
        return fa.reduceRight(function(b2, a, i) {
          return f(i, a, b2);
        }, b);
      };
    };
    traverse3 = function(F) {
      var traverseWithIndexF = traverseWithIndex2(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence3 = function(F) {
      return function(ta) {
        return _reduce3(ta, F.of(zero()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return pipe(as, append3(a));
            };
          }), fa);
        });
      };
    };
    traverseWithIndex2 = function(F) {
      return function(f) {
        return reduceWithIndex3(F.of(zero()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return pipe(bs, append3(b));
            };
          }), f(i, a));
        });
      };
    };
    URI5 = "ReadonlyArray";
    getShow4 = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    getEq4 = function(E) {
      return fromEquals(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    getOrd = function(O) {
      return fromCompare(function(a, b) {
        var aLen = a.length;
        var bLen = b.length;
        var len = Math.min(aLen, bLen);
        for (var i = 0; i < len; i++) {
          var ordering = O.compare(a[i], b[i]);
          if (ordering !== 0) {
            return ordering;
          }
        }
        return Ord.compare(aLen, bLen);
      });
    };
    Functor5 = {
      URI: URI5,
      map: _map5
    };
    flap6 = flap(Functor5);
    Pointed3 = {
      URI: URI5,
      of: of4
    };
    Apply4 = {
      URI: URI5,
      map: _map5,
      ap: _ap4
    };
    apFirst5 = apFirst(Apply4);
    apSecond5 = apSecond(Apply4);
    Chain4 = {
      URI: URI5,
      map: _map5,
      ap: _ap4,
      chain: _chain4
    };
    chainFirst5 = chainFirst(Chain4);
    Zero = {
      URI: URI5,
      zero
    };
    guard2 = guard(Zero, Pointed3);
    Compactable = {
      URI: URI5,
      compact,
      separate
    };
    Traversable3 = {
      URI: URI5,
      map: _map5,
      reduce: _reduce3,
      foldMap: _foldMap3,
      reduceRight: _reduceRight3,
      traverse: _traverse3,
      sequence: sequence3
    };
    chainRecDepthFirst = function(f) {
      return function(a) {
        var todo = __spreadArray5([], f(a), true);
        var out = [];
        while (todo.length > 0) {
          var e = todo.shift();
          if (isLeft(e)) {
            todo.unshift.apply(todo, f(e.left));
          } else {
            out.push(e.right);
          }
        }
        return out;
      };
    };
    chainRecBreadthFirst = function(f) {
      return function(a) {
        var initial = f(a);
        var todo = [];
        var out = [];
        function go(e2) {
          if (isLeft(e2)) {
            f(e2.left).forEach(function(v) {
              return todo.push(v);
            });
          } else {
            out.push(e2.right);
          }
        }
        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
          var e = initial_1[_i];
          go(e);
        }
        while (todo.length > 0) {
          go(todo.shift());
        }
        return out;
      };
    };
    _wither = witherDefault(Traversable3, Compactable);
    _wilt = wiltDefault(Traversable3, Compactable);
    Witherable = {
      URI: URI5,
      map: _map5,
      compact,
      separate,
      filter: _filter,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      reduce: _reduce3,
      foldMap: _foldMap3,
      reduceRight: _reduceRight3,
      traverse: _traverse3,
      sequence: sequence3,
      wither: _wither,
      wilt: _wilt
    };
    filterE2 = filterE(Witherable);
    FromEither2 = {
      URI: URI5,
      fromEither
    };
    fromEitherK2 = fromEitherK(FromEither2);
    empty2 = empty;
    intercalate3 = function(M) {
      var intercalateM = intercalate(M);
      return function(middle) {
        return match2(function() {
          return M.empty;
        }, intercalateM(middle));
      };
    };
    Do4 = of4(emptyRecord);
    bindTo5 = bindTo(Functor5);
    let_5 = let_(Functor5);
    bind5 = bind(Chain4);
    apS5 = apS(Apply4);
  }
});

// node_modules/fp-ts/es6/Array.js
var Array_exports = {};
__export(Array_exports, {
  Alt: () => Alt3,
  Alternative: () => Alternative,
  Applicative: () => Applicative3,
  Apply: () => Apply5,
  Chain: () => Chain5,
  ChainRecBreadthFirst: () => ChainRecBreadthFirst,
  ChainRecDepthFirst: () => ChainRecDepthFirst,
  Compactable: () => Compactable2,
  Do: () => Do5,
  Extend: () => Extend2,
  Filterable: () => Filterable,
  FilterableWithIndex: () => FilterableWithIndex,
  Foldable: () => Foldable3,
  FoldableWithIndex: () => FoldableWithIndex2,
  FromEither: () => FromEither3,
  Functor: () => Functor6,
  FunctorWithIndex: () => FunctorWithIndex2,
  Monad: () => Monad3,
  Pointed: () => Pointed4,
  Traversable: () => Traversable4,
  TraversableWithIndex: () => TraversableWithIndex2,
  URI: () => URI6,
  Unfoldable: () => Unfoldable,
  Witherable: () => Witherable2,
  Zero: () => Zero2,
  alt: () => alt3,
  altW: () => altW3,
  ap: () => ap6,
  apFirst: () => apFirst6,
  apS: () => apS6,
  apSecond: () => apSecond6,
  append: () => append4,
  appendW: () => appendW3,
  array: () => array2,
  bind: () => bind6,
  bindTo: () => bindTo6,
  chain: () => chain5,
  chainFirst: () => chainFirst6,
  chainRecBreadthFirst: () => chainRecBreadthFirst2,
  chainRecDepthFirst: () => chainRecDepthFirst2,
  chainWithIndex: () => chainWithIndex4,
  chop: () => chop3,
  chunksOf: () => chunksOf3,
  compact: () => compact2,
  comprehension: () => comprehension,
  concat: () => concat2,
  concatW: () => concatW2,
  cons: () => cons3,
  copy: () => copy2,
  deleteAt: () => deleteAt,
  difference: () => difference,
  dropLeft: () => dropLeft,
  dropLeftWhile: () => dropLeftWhile,
  dropRight: () => dropRight,
  duplicate: () => duplicate5,
  elem: () => elem3,
  empty: () => empty3,
  every: () => every2,
  exists: () => exists2,
  extend: () => extend5,
  filter: () => filter3,
  filterE: () => filterE3,
  filterMap: () => filterMap2,
  filterMapWithIndex: () => filterMapWithIndex2,
  filterWithIndex: () => filterWithIndex2,
  findFirst: () => findFirst2,
  findFirstMap: () => findFirstMap2,
  findIndex: () => findIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  findLastMap: () => findLastMap2,
  flap: () => flap7,
  flatten: () => flatten5,
  foldLeft: () => foldLeft,
  foldMap: () => foldMap5,
  foldMapWithIndex: () => foldMapWithIndex4,
  foldRight: () => foldRight,
  fromEither: () => fromEither2,
  fromEitherK: () => fromEitherK3,
  fromOption: () => fromOption3,
  fromOptionK: () => fromOptionK3,
  fromPredicate: () => fromPredicate3,
  getDifferenceMagma: () => getDifferenceMagma,
  getEq: () => getEq5,
  getIntersectionSemigroup: () => getIntersectionSemigroup,
  getMonoid: () => getMonoid2,
  getOrd: () => getOrd2,
  getSemigroup: () => getSemigroup5,
  getShow: () => getShow5,
  getUnionMonoid: () => getUnionMonoid,
  getUnionSemigroup: () => getUnionSemigroup2,
  guard: () => guard3,
  head: () => head5,
  init: () => init3,
  insertAt: () => insertAt2,
  intercalate: () => intercalate4,
  intersection: () => intersection2,
  intersperse: () => intersperse3,
  isEmpty: () => isEmpty2,
  isNonEmpty: () => isNonEmpty6,
  isOutOfBound: () => isOutOfBound4,
  last: () => last5,
  lefts: () => lefts,
  let: () => let_6,
  lookup: () => lookup2,
  makeBy: () => makeBy3,
  map: () => map6,
  mapWithIndex: () => mapWithIndex3,
  match: () => match3,
  matchLeft: () => matchLeft2,
  matchLeftW: () => matchLeftW,
  matchRight: () => matchRight2,
  matchRightW: () => matchRightW,
  matchW: () => matchW3,
  modifyAt: () => modifyAt2,
  of: () => of5,
  partition: () => partition2,
  partitionMap: () => partitionMap2,
  partitionMapWithIndex: () => partitionMapWithIndex2,
  partitionWithIndex: () => partitionWithIndex2,
  prepend: () => prepend3,
  prependAll: () => prependAll3,
  prependToAll: () => prependToAll2,
  prependW: () => prependW3,
  range: () => range3,
  reduce: () => reduce5,
  reduceRight: () => reduceRight5,
  reduceRightWithIndex: () => reduceRightWithIndex4,
  reduceWithIndex: () => reduceWithIndex4,
  replicate: () => replicate2,
  reverse: () => reverse3,
  rights: () => rights,
  rotate: () => rotate3,
  scanLeft: () => scanLeft,
  scanRight: () => scanRight,
  separate: () => separate2,
  sequence: () => sequence4,
  size: () => size,
  snoc: () => snoc3,
  some: () => some2,
  sort: () => sort2,
  sortBy: () => sortBy3,
  spanLeft: () => spanLeft,
  splitAt: () => splitAt3,
  tail: () => tail4,
  takeLeft: () => takeLeft,
  takeLeftWhile: () => takeLeftWhile,
  takeRight: () => takeRight,
  traverse: () => traverse4,
  traverseWithIndex: () => traverseWithIndex3,
  unfold: () => unfold,
  union: () => union4,
  uniq: () => uniq3,
  unsafeDeleteAt: () => unsafeDeleteAt,
  unsafeInsertAt: () => unsafeInsertAt3,
  unsafeUpdateAt: () => unsafeUpdateAt3,
  unzip: () => unzip2,
  updateAt: () => updateAt2,
  wilt: () => wilt,
  wither: () => wither,
  zero: () => zero2,
  zip: () => zip2,
  zipWith: () => zipWith2
});
function fromPredicate3(predicate) {
  return function(a) {
    return predicate(a) ? [a] : [];
  };
}
function takeLeftWhile(predicate) {
  return function(as) {
    var out = [];
    for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
      var a = as_1[_i];
      if (!predicate(a)) {
        break;
      }
      out.push(a);
    }
    return out;
  };
}
function spanLeft(predicate) {
  return function(as) {
    var _a = splitAt3(spanLeftIndex(as, predicate))(as), init4 = _a[0], rest = _a[1];
    return { init: init4, rest };
  };
}
function dropLeftWhile(predicate) {
  return function(as) {
    return as.slice(spanLeftIndex(as, predicate));
  };
}
function findFirst2(predicate) {
  return findFirst(predicate);
}
function findLast2(predicate) {
  return findLast(predicate);
}
function zip2(as, bs) {
  if (bs === void 0) {
    return function(bs2) {
      return zip2(bs2, as);
    };
  }
  return zipWith2(as, bs, function(a, b) {
    return [a, b];
  });
}
function comprehension(input, f, g) {
  if (g === void 0) {
    g = function() {
      return true;
    };
  }
  var go = function(scope, input2) {
    return isNonEmpty6(input2) ? pipe(head3(input2), chain5(function(x) {
      return go(pipe(scope, append4(x)), tail3(input2));
    })) : g.apply(void 0, scope) ? [f.apply(void 0, scope)] : [];
  };
  return go([], input);
}
function union4(E) {
  var unionE = union2(E);
  return function(first2, second) {
    if (second === void 0) {
      var unionE_1 = union4(E);
      return function(second2) {
        return unionE_1(second2, first2);
      };
    }
    return isNonEmpty6(first2) && isNonEmpty6(second) ? unionE(second)(first2) : isNonEmpty6(first2) ? copy2(first2) : copy2(second);
  };
}
function intersection2(E) {
  var elemE = elem3(E);
  return function(xs, ys) {
    if (ys === void 0) {
      var intersectionE_1 = intersection2(E);
      return function(ys2) {
        return intersectionE_1(ys2, xs);
      };
    }
    return xs.filter(function(a) {
      return elemE(a, ys);
    });
  };
}
function difference(E) {
  var elemE = elem3(E);
  return function(xs, ys) {
    if (ys === void 0) {
      var differenceE_1 = difference(E);
      return function(ys2) {
        return differenceE_1(ys2, xs);
      };
    }
    return xs.filter(function(a) {
      return !elemE(a, ys);
    });
  };
}
var isEmpty2, isNonEmpty6, prepend3, prependW3, append4, appendW3, makeBy3, replicate2, fromOption3, fromEither2, matchW3, match3, matchLeftW, matchLeft2, foldLeft, matchRightW, matchRight2, foldRight, chainWithIndex4, scanLeft, scanRight, size, isOutOfBound4, lookup2, head5, last5, tail4, init3, takeLeft, takeRight, spanLeftIndex, dropLeft, dropRight, findIndex2, findFirstMap2, findLastMap2, findLastIndex2, copy2, insertAt2, updateAt2, deleteAt, modifyAt2, reverse3, rights, lefts, sort2, zipWith2, unzip2, prependAll3, intersperse3, rotate3, elem3, uniq3, sortBy3, chop3, splitAt3, chunksOf3, fromOptionK3, concatW2, concat2, _map6, _mapWithIndex2, _ap5, _chain5, _filter2, _filterMap2, _partition2, _partitionMap2, _partitionWithIndex, _partitionMapWithIndex, _alt3, _reduce4, _foldMap4, _reduceRight4, _reduceWithIndex2, _foldMapWithIndex2, _reduceRightWithIndex2, _filterMapWithIndex, _filterWithIndex, _extend3, _traverse4, _traverseWithIndex2, _chainRecDepthFirst2, _chainRecBreadthFirst2, of5, zero2, map6, ap6, chain5, flatten5, mapWithIndex3, filterMapWithIndex2, filterMap2, compact2, separate2, filter3, partition2, partitionWithIndex2, partitionMap2, partitionMapWithIndex2, altW3, alt3, filterWithIndex2, extend5, duplicate5, foldMap5, foldMapWithIndex4, reduce5, reduceWithIndex4, reduceRight5, reduceRightWithIndex4, traverse4, sequence4, traverseWithIndex3, wither, wilt, unfold, URI6, getShow5, getSemigroup5, getMonoid2, getEq5, getOrd2, getUnionSemigroup2, getUnionMonoid, getIntersectionSemigroup, getDifferenceMagma, Functor6, flap7, Pointed4, FunctorWithIndex2, Apply5, apFirst6, apSecond6, Applicative3, Chain5, chainFirst6, Monad3, Unfoldable, Alt3, Zero2, guard3, Alternative, Extend2, Compactable2, Filterable, FilterableWithIndex, Foldable3, FoldableWithIndex2, Traversable4, TraversableWithIndex2, _wither2, _wilt2, Witherable2, chainRecDepthFirst2, ChainRecDepthFirst, chainRecBreadthFirst2, ChainRecBreadthFirst, filterE3, FromEither3, fromEitherK3, unsafeInsertAt3, unsafeUpdateAt3, unsafeDeleteAt, every2, some2, exists2, intercalate4, Do5, bindTo6, let_6, bind6, apS6, range3, empty3, cons3, snoc3, prependToAll2, array2;
var init_Array = __esm({
  "node_modules/fp-ts/es6/Array.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_NonEmptyArray();
    init_ReadonlyArray();
    init_Separated();
    init_Witherable();
    init_Zero();
    isEmpty2 = function(as) {
      return as.length === 0;
    };
    isNonEmpty6 = isNonEmpty4;
    prepend3 = prepend2;
    prependW3 = prependW2;
    append4 = append2;
    appendW3 = appendW2;
    makeBy3 = function(n, f) {
      return n <= 0 ? [] : makeBy(f)(n);
    };
    replicate2 = function(n, a) {
      return makeBy3(n, function() {
        return a;
      });
    };
    fromOption3 = function(ma) {
      return isNone(ma) ? [] : [ma.value];
    };
    fromEither2 = function(e) {
      return isLeft(e) ? [] : [e.right];
    };
    matchW3 = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    match3 = matchW3;
    matchLeftW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(head3(as), tail3(as)) : onEmpty();
      };
    };
    matchLeft2 = matchLeftW;
    foldLeft = matchLeft2;
    matchRightW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(init(as), last3(as)) : onEmpty();
      };
    };
    matchRight2 = matchRightW;
    foldRight = matchRight2;
    chainWithIndex4 = function(f) {
      return function(as) {
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    scanLeft = function(b, f) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
          out[i + 1] = f(out[i], as[i]);
        }
        return out;
      };
    };
    scanRight = function(b, f) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
          out[i] = f(as[i], out[i + 1]);
        }
        return out;
      };
    };
    size = function(as) {
      return as.length;
    };
    isOutOfBound4 = isOutOfBound2;
    lookup2 = lookup;
    head5 = head4;
    last5 = last4;
    tail4 = function(as) {
      return isNonEmpty6(as) ? some(tail3(as)) : none;
    };
    init3 = function(as) {
      return isNonEmpty6(as) ? some(init(as)) : none;
    };
    takeLeft = function(n) {
      return function(as) {
        return isOutOfBound4(n, as) ? copy2(as) : as.slice(0, n);
      };
    };
    takeRight = function(n) {
      return function(as) {
        return isOutOfBound4(n, as) ? copy2(as) : n === 0 ? [] : as.slice(-n);
      };
    };
    spanLeftIndex = function(as, predicate) {
      var l = as.length;
      var i = 0;
      for (; i < l; i++) {
        if (!predicate(as[i])) {
          break;
        }
      }
      return i;
    };
    dropLeft = function(n) {
      return function(as) {
        return n <= 0 || isEmpty2(as) ? copy2(as) : n >= as.length ? [] : as.slice(n, as.length);
      };
    };
    dropRight = function(n) {
      return function(as) {
        return n <= 0 || isEmpty2(as) ? copy2(as) : n >= as.length ? [] : as.slice(0, as.length - n);
      };
    };
    findIndex2 = findIndex;
    findFirstMap2 = findFirstMap;
    findLastMap2 = findLastMap;
    findLastIndex2 = findLastIndex;
    copy2 = function(as) {
      return as.slice();
    };
    insertAt2 = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? none : some(unsafeInsertAt3(i, a, as));
      };
    };
    updateAt2 = function(i, a) {
      return modifyAt2(i, function() {
        return a;
      });
    };
    deleteAt = function(i) {
      return function(as) {
        return isOutOfBound4(i, as) ? none : some(unsafeDeleteAt(i, as));
      };
    };
    modifyAt2 = function(i, f) {
      return function(as) {
        return isOutOfBound4(i, as) ? none : some(unsafeUpdateAt3(i, f(as[i]), as));
      };
    };
    reverse3 = function(as) {
      return isEmpty2(as) ? [] : as.slice().reverse();
    };
    rights = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Right") {
          r.push(a.right);
        }
      }
      return r;
    };
    lefts = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Left") {
          r.push(a.left);
        }
      }
      return r;
    };
    sort2 = function(O) {
      return function(as) {
        return as.length <= 1 ? copy2(as) : as.slice().sort(O.compare);
      };
    };
    zipWith2 = function(fa, fb, f) {
      var fc = [];
      var len = Math.min(fa.length, fb.length);
      for (var i = 0; i < len; i++) {
        fc[i] = f(fa[i], fb[i]);
      }
      return fc;
    };
    unzip2 = function(as) {
      var fa = [];
      var fb = [];
      for (var i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
      }
      return [fa, fb];
    };
    prependAll3 = function(middle) {
      var f = prependAll2(middle);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : [];
      };
    };
    intersperse3 = function(middle) {
      var f = intersperse2(middle);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    rotate3 = function(n) {
      var f = rotate(n);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    elem3 = elem2;
    uniq3 = function(E) {
      var f = uniq(E);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    sortBy3 = function(ords) {
      var f = sortBy(ords);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    chop3 = function(f) {
      var g = chop(f);
      return function(as) {
        return isNonEmpty6(as) ? g(as) : [];
      };
    };
    splitAt3 = function(n) {
      return function(as) {
        return n >= 1 && isNonEmpty6(as) ? splitAt(n)(as) : isEmpty2(as) ? [copy2(as), []] : [[], copy2(as)];
      };
    };
    chunksOf3 = function(n) {
      var f = chunksOf(n);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : [];
      };
    };
    fromOptionK3 = function(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return fromOption3(f.apply(void 0, a));
      };
    };
    concatW2 = function(second) {
      return function(first2) {
        return isEmpty2(first2) ? copy2(second) : isEmpty2(second) ? copy2(first2) : first2.concat(second);
      };
    };
    concat2 = concatW2;
    _map6 = function(fa, f) {
      return pipe(fa, map6(f));
    };
    _mapWithIndex2 = function(fa, f) {
      return pipe(fa, mapWithIndex3(f));
    };
    _ap5 = function(fab, fa) {
      return pipe(fab, ap6(fa));
    };
    _chain5 = function(ma, f) {
      return pipe(ma, chain5(f));
    };
    _filter2 = function(fa, predicate) {
      return pipe(fa, filter3(predicate));
    };
    _filterMap2 = function(fa, f) {
      return pipe(fa, filterMap2(f));
    };
    _partition2 = function(fa, predicate) {
      return pipe(fa, partition2(predicate));
    };
    _partitionMap2 = function(fa, f) {
      return pipe(fa, partitionMap2(f));
    };
    _partitionWithIndex = function(fa, predicateWithIndex) {
      return pipe(fa, partitionWithIndex2(predicateWithIndex));
    };
    _partitionMapWithIndex = function(fa, f) {
      return pipe(fa, partitionMapWithIndex2(f));
    };
    _alt3 = function(fa, that) {
      return pipe(fa, alt3(that));
    };
    _reduce4 = function(fa, b, f) {
      return pipe(fa, reduce5(b, f));
    };
    _foldMap4 = function(M) {
      var foldMapM = foldMap5(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight4 = function(fa, b, f) {
      return pipe(fa, reduceRight5(b, f));
    };
    _reduceWithIndex2 = function(fa, b, f) {
      return pipe(fa, reduceWithIndex4(b, f));
    };
    _foldMapWithIndex2 = function(M) {
      var foldMapWithIndexM = foldMapWithIndex4(M);
      return function(fa, f) {
        return pipe(fa, foldMapWithIndexM(f));
      };
    };
    _reduceRightWithIndex2 = function(fa, b, f) {
      return pipe(fa, reduceRightWithIndex4(b, f));
    };
    _filterMapWithIndex = function(fa, f) {
      return pipe(fa, filterMapWithIndex2(f));
    };
    _filterWithIndex = function(fa, predicateWithIndex) {
      return pipe(fa, filterWithIndex2(predicateWithIndex));
    };
    _extend3 = function(fa, f) {
      return pipe(fa, extend5(f));
    };
    _traverse4 = function(F) {
      var traverseF = traverse4(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _traverseWithIndex2 = function(F) {
      var traverseWithIndexF = traverseWithIndex3(F);
      return function(ta, f) {
        return pipe(ta, traverseWithIndexF(f));
      };
    };
    _chainRecDepthFirst2 = _chainRecDepthFirst;
    _chainRecBreadthFirst2 = _chainRecBreadthFirst;
    of5 = of3;
    zero2 = function() {
      return [];
    };
    map6 = function(f) {
      return function(fa) {
        return fa.map(function(a) {
          return f(a);
        });
      };
    };
    ap6 = function(fa) {
      return chain5(function(f) {
        return pipe(fa, map6(f));
      });
    };
    chain5 = function(f) {
      return function(ma) {
        return pipe(ma, chainWithIndex4(function(_, a) {
          return f(a);
        }));
      };
    };
    flatten5 = chain5(identity);
    mapWithIndex3 = function(f) {
      return function(fa) {
        return fa.map(function(a, i) {
          return f(i, a);
        });
      };
    };
    filterMapWithIndex2 = function(f) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f(i, fa[i]);
          if (isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    filterMap2 = function(f) {
      return filterMapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    compact2 = filterMap2(identity);
    separate2 = function(fa) {
      var left4 = [];
      var right4 = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left4.push(e.left);
        } else {
          right4.push(e.right);
        }
      }
      return separated(left4, right4);
    };
    filter3 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    partition2 = function(predicate) {
      return partitionWithIndex2(function(_, a) {
        return predicate(a);
      });
    };
    partitionWithIndex2 = function(predicateWithIndex) {
      return function(as) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < as.length; i++) {
          var b = as[i];
          if (predicateWithIndex(i, b)) {
            right4.push(b);
          } else {
            left4.push(b);
          }
        }
        return separated(left4, right4);
      };
    };
    partitionMap2 = function(f) {
      return partitionMapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    partitionMapWithIndex2 = function(f) {
      return function(fa) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f(i, fa[i]);
          if (e._tag === "Left") {
            left4.push(e.left);
          } else {
            right4.push(e.right);
          }
        }
        return separated(left4, right4);
      };
    };
    altW3 = function(that) {
      return function(fa) {
        return fa.concat(that());
      };
    };
    alt3 = altW3;
    filterWithIndex2 = function(predicateWithIndex) {
      return function(as) {
        return as.filter(function(b, i) {
          return predicateWithIndex(i, b);
        });
      };
    };
    extend5 = function(f) {
      return function(wa) {
        return wa.map(function(_, i) {
          return f(wa.slice(i));
        });
      };
    };
    duplicate5 = extend5(identity);
    foldMap5 = foldMap4;
    foldMapWithIndex4 = foldMapWithIndex3;
    reduce5 = reduce4;
    reduceWithIndex4 = reduceWithIndex3;
    reduceRight5 = reduceRight4;
    reduceRightWithIndex4 = reduceRightWithIndex3;
    traverse4 = function(F) {
      var traverseWithIndexF = traverseWithIndex3(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence4 = function(F) {
      return function(ta) {
        return _reduce4(ta, F.of(zero2()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return pipe(as, append4(a));
            };
          }), fa);
        });
      };
    };
    traverseWithIndex3 = function(F) {
      return function(f) {
        return reduceWithIndex4(F.of(zero2()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return pipe(bs, append4(b));
            };
          }), f(i, a));
        });
      };
    };
    wither = function(F) {
      var _witherF = _wither2(F);
      return function(f) {
        return function(fa) {
          return _witherF(fa, f);
        };
      };
    };
    wilt = function(F) {
      var _wiltF = _wilt2(F);
      return function(f) {
        return function(fa) {
          return _wiltF(fa, f);
        };
      };
    };
    unfold = function(b, f) {
      var out = [];
      var bb = b;
      while (true) {
        var mt = f(bb);
        if (isSome(mt)) {
          var _a = mt.value, a = _a[0], b_1 = _a[1];
          out.push(a);
          bb = b_1;
        } else {
          break;
        }
      }
      return out;
    };
    URI6 = "Array";
    getShow5 = getShow4;
    getSemigroup5 = function() {
      return {
        concat: function(first2, second) {
          return first2.concat(second);
        }
      };
    };
    getMonoid2 = function() {
      return {
        concat: getSemigroup5().concat,
        empty: []
      };
    };
    getEq5 = getEq4;
    getOrd2 = getOrd;
    getUnionSemigroup2 = function(E) {
      var unionE = union4(E);
      return {
        concat: function(first2, second) {
          return unionE(second)(first2);
        }
      };
    };
    getUnionMonoid = function(E) {
      return {
        concat: getUnionSemigroup2(E).concat,
        empty: []
      };
    };
    getIntersectionSemigroup = function(E) {
      var intersectionE = intersection2(E);
      return {
        concat: function(first2, second) {
          return intersectionE(second)(first2);
        }
      };
    };
    getDifferenceMagma = function(E) {
      var differenceE = difference(E);
      return {
        concat: function(first2, second) {
          return differenceE(second)(first2);
        }
      };
    };
    Functor6 = {
      URI: URI6,
      map: _map6
    };
    flap7 = flap(Functor6);
    Pointed4 = {
      URI: URI6,
      of: of5
    };
    FunctorWithIndex2 = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2
    };
    Apply5 = {
      URI: URI6,
      map: _map6,
      ap: _ap5
    };
    apFirst6 = apFirst(Apply5);
    apSecond6 = apSecond(Apply5);
    Applicative3 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5
    };
    Chain5 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5
    };
    chainFirst6 = chainFirst(Chain5);
    Monad3 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5,
      chain: _chain5
    };
    Unfoldable = {
      URI: URI6,
      unfold
    };
    Alt3 = {
      URI: URI6,
      map: _map6,
      alt: _alt3
    };
    Zero2 = {
      URI: URI6,
      zero: zero2
    };
    guard3 = guard(Zero2, Pointed4);
    Alternative = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5,
      alt: _alt3,
      zero: zero2
    };
    Extend2 = {
      URI: URI6,
      map: _map6,
      extend: _extend3
    };
    Compactable2 = {
      URI: URI6,
      compact: compact2,
      separate: separate2
    };
    Filterable = {
      URI: URI6,
      map: _map6,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2
    };
    FilterableWithIndex = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex
    };
    Foldable3 = {
      URI: URI6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4
    };
    FoldableWithIndex2 = {
      URI: URI6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2
    };
    Traversable4 = {
      URI: URI6,
      map: _map6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4
    };
    TraversableWithIndex2 = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2,
      traverse: _traverse4,
      sequence: sequence4,
      traverseWithIndex: _traverseWithIndex2
    };
    _wither2 = witherDefault(Traversable4, Compactable2);
    _wilt2 = wiltDefault(Traversable4, Compactable2);
    Witherable2 = {
      URI: URI6,
      map: _map6,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4,
      wither: _wither2,
      wilt: _wilt2
    };
    chainRecDepthFirst2 = chainRecDepthFirst;
    ChainRecDepthFirst = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5,
      chainRec: _chainRecDepthFirst2
    };
    chainRecBreadthFirst2 = chainRecBreadthFirst;
    ChainRecBreadthFirst = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5,
      chainRec: _chainRecBreadthFirst2
    };
    filterE3 = filterE(Witherable2);
    FromEither3 = {
      URI: URI6,
      fromEither: fromEither2
    };
    fromEitherK3 = fromEitherK(FromEither3);
    unsafeInsertAt3 = unsafeInsertAt;
    unsafeUpdateAt3 = function(i, a, as) {
      return isNonEmpty6(as) ? unsafeUpdateAt(i, a, as) : [];
    };
    unsafeDeleteAt = function(i, as) {
      var xs = as.slice();
      xs.splice(i, 1);
      return xs;
    };
    every2 = every;
    some2 = function(predicate) {
      return function(as) {
        return as.some(predicate);
      };
    };
    exists2 = some2;
    intercalate4 = intercalate3;
    Do5 = of5(emptyRecord);
    bindTo6 = bindTo(Functor6);
    let_6 = let_(Functor6);
    bind6 = bind(Chain5);
    apS6 = apS(Apply5);
    range3 = range;
    empty3 = [];
    cons3 = cons;
    snoc3 = snoc;
    prependToAll2 = prependAll3;
    array2 = {
      URI: URI6,
      compact: compact2,
      separate: separate2,
      map: _map6,
      ap: _ap5,
      of: of5,
      chain: _chain5,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      mapWithIndex: _mapWithIndex2,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex,
      alt: _alt3,
      zero: zero2,
      unfold,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2,
      traverseWithIndex: _traverseWithIndex2,
      extend: _extend3,
      wither: _wither2,
      wilt: _wilt2
    };
  }
});

// node_modules/fp-ts/es6/Predicate.js
var not;
var init_Predicate = __esm({
  "node_modules/fp-ts/es6/Predicate.js"() {
    init_shim();
    init_function();
    not = function(predicate) {
      return function(a) {
        return !predicate(a);
      };
    };
  }
});

// node_modules/fp-ts/es6/Option.js
var Option_exports = {};
__export(Option_exports, {
  Alt: () => Alt4,
  Alternative: () => Alternative2,
  ApT: () => ApT2,
  Applicative: () => Applicative4,
  Apply: () => Apply6,
  Chain: () => Chain6,
  Compactable: () => Compactable3,
  Do: () => Do6,
  Extend: () => Extend3,
  Filterable: () => Filterable2,
  Foldable: () => Foldable4,
  FromEither: () => FromEither4,
  Functor: () => Functor7,
  Monad: () => Monad4,
  MonadThrow: () => MonadThrow2,
  Pointed: () => Pointed5,
  Traversable: () => Traversable5,
  URI: () => URI7,
  Witherable: () => Witherable3,
  Zero: () => Zero3,
  alt: () => alt4,
  altW: () => altW4,
  ap: () => ap7,
  apFirst: () => apFirst7,
  apS: () => apS7,
  apSecond: () => apSecond7,
  bind: () => bind7,
  bindTo: () => bindTo7,
  chain: () => chain6,
  chainEitherK: () => chainEitherK2,
  chainFirst: () => chainFirst7,
  chainFirstEitherK: () => chainFirstEitherK2,
  chainNullableK: () => chainNullableK2,
  compact: () => compact3,
  duplicate: () => duplicate6,
  elem: () => elem4,
  exists: () => exists3,
  extend: () => extend6,
  filter: () => filter4,
  filterMap: () => filterMap3,
  flap: () => flap8,
  flatten: () => flatten6,
  fold: () => fold3,
  foldMap: () => foldMap6,
  foldW: () => foldW2,
  fromEither: () => fromEither3,
  fromEitherK: () => fromEitherK4,
  fromNullable: () => fromNullable2,
  fromNullableK: () => fromNullableK2,
  fromPredicate: () => fromPredicate4,
  getApplyMonoid: () => getApplyMonoid2,
  getApplySemigroup: () => getApplySemigroup3,
  getEq: () => getEq6,
  getFirstMonoid: () => getFirstMonoid,
  getLastMonoid: () => getLastMonoid,
  getLeft: () => getLeft,
  getMonoid: () => getMonoid3,
  getOrElse: () => getOrElse2,
  getOrElseW: () => getOrElseW2,
  getOrd: () => getOrd3,
  getRefinement: () => getRefinement,
  getRight: () => getRight,
  getShow: () => getShow6,
  guard: () => guard4,
  isNone: () => isNone2,
  isSome: () => isSome2,
  let: () => let_7,
  map: () => map7,
  mapNullable: () => mapNullable,
  match: () => match4,
  matchW: () => matchW4,
  none: () => none2,
  of: () => of6,
  option: () => option,
  partition: () => partition3,
  partitionMap: () => partitionMap3,
  reduce: () => reduce6,
  reduceRight: () => reduceRight6,
  separate: () => separate3,
  sequence: () => sequence5,
  sequenceArray: () => sequenceArray2,
  some: () => some3,
  throwError: () => throwError2,
  toNullable: () => toNullable,
  toUndefined: () => toUndefined,
  traverse: () => traverse5,
  traverseArray: () => traverseArray2,
  traverseArrayWithIndex: () => traverseArrayWithIndex2,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex2,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex2,
  tryCatch: () => tryCatch2,
  tryCatchK: () => tryCatchK2,
  wilt: () => wilt2,
  wither: () => wither2,
  zero: () => zero3
});
function fromPredicate4(predicate) {
  return function(a) {
    return predicate(a) ? some3(a) : none2;
  };
}
function elem4(E) {
  return function(a, ma) {
    if (ma === void 0) {
      var elemE_1 = elem4(E);
      return function(ma2) {
        return elemE_1(a, ma2);
      };
    }
    return isNone2(ma) ? false : E.equals(a, ma.value);
  };
}
function getRefinement(getOption) {
  return function(a) {
    return isSome2(getOption(a));
  };
}
var none2, some3, getLeft, getRight, _map7, _ap6, _chain6, _reduce5, _foldMap5, _reduceRight5, _traverse5, _alt4, _filter3, _filterMap3, _extend4, _partition3, _partitionMap3, URI7, getShow6, getEq6, getOrd3, getMonoid3, map7, Functor7, of6, Pointed5, ap7, Apply6, Applicative4, chain6, Chain6, Monad4, reduce6, foldMap6, reduceRight6, Foldable4, altW4, alt4, Alt4, zero3, Zero3, guard4, Alternative2, extend6, Extend3, compact3, defaultSeparated, separate3, Compactable3, filter4, filterMap3, partition3, partitionMap3, Filterable2, traverse5, sequence5, Traversable5, _wither3, _wilt3, wither2, wilt2, Witherable3, throwError2, MonadThrow2, fromEither3, FromEither4, isSome2, isNone2, matchW4, foldW2, match4, fold3, getOrElseW2, getOrElse2, flap8, apFirst7, apSecond7, flatten6, chainFirst7, duplicate6, fromEitherK4, chainEitherK2, chainFirstEitherK2, fromNullable2, tryCatch2, tryCatchK2, fromNullableK2, chainNullableK2, toNullable, toUndefined, exists3, Do6, bindTo7, let_7, bind7, apS7, ApT2, traverseReadonlyNonEmptyArrayWithIndex2, traverseReadonlyArrayWithIndex2, traverseArrayWithIndex2, traverseArray2, sequenceArray2, mapNullable, option, getApplySemigroup3, getApplyMonoid2, getFirstMonoid, getLastMonoid;
var init_Option = __esm({
  "node_modules/fp-ts/es6/Option.js"() {
    init_shim();
    init_Applicative();
    init_Apply();
    init_Chain();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_Predicate();
    init_Semigroup();
    init_Separated();
    init_Witherable();
    init_Zero();
    none2 = none;
    some3 = some;
    getLeft = function(ma) {
      return ma._tag === "Right" ? none2 : some3(ma.left);
    };
    getRight = function(ma) {
      return ma._tag === "Left" ? none2 : some3(ma.right);
    };
    _map7 = function(fa, f) {
      return pipe(fa, map7(f));
    };
    _ap6 = function(fab, fa) {
      return pipe(fab, ap7(fa));
    };
    _chain6 = function(ma, f) {
      return pipe(ma, chain6(f));
    };
    _reduce5 = function(fa, b, f) {
      return pipe(fa, reduce6(b, f));
    };
    _foldMap5 = function(M) {
      var foldMapM = foldMap6(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight5 = function(fa, b, f) {
      return pipe(fa, reduceRight6(b, f));
    };
    _traverse5 = function(F) {
      var traverseF = traverse5(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _alt4 = function(fa, that) {
      return pipe(fa, alt4(that));
    };
    _filter3 = function(fa, predicate) {
      return pipe(fa, filter4(predicate));
    };
    _filterMap3 = function(fa, f) {
      return pipe(fa, filterMap3(f));
    };
    _extend4 = function(wa, f) {
      return pipe(wa, extend6(f));
    };
    _partition3 = function(fa, predicate) {
      return pipe(fa, partition3(predicate));
    };
    _partitionMap3 = function(fa, f) {
      return pipe(fa, partitionMap3(f));
    };
    URI7 = "Option";
    getShow6 = function(S) {
      return {
        show: function(ma) {
          return isNone2(ma) ? "none" : "some(".concat(S.show(ma.value), ")");
        }
      };
    };
    getEq6 = function(E) {
      return {
        equals: function(x, y) {
          return x === y || (isNone2(x) ? isNone2(y) : isNone2(y) ? false : E.equals(x.value, y.value));
        }
      };
    };
    getOrd3 = function(O) {
      return {
        equals: getEq6(O).equals,
        compare: function(x, y) {
          return x === y ? 0 : isSome2(x) ? isSome2(y) ? O.compare(x.value, y.value) : 1 : -1;
        }
      };
    };
    getMonoid3 = function(S) {
      return {
        concat: function(x, y) {
          return isNone2(x) ? y : isNone2(y) ? x : some3(S.concat(x.value, y.value));
        },
        empty: none2
      };
    };
    map7 = function(f) {
      return function(fa) {
        return isNone2(fa) ? none2 : some3(f(fa.value));
      };
    };
    Functor7 = {
      URI: URI7,
      map: _map7
    };
    of6 = some3;
    Pointed5 = {
      URI: URI7,
      of: of6
    };
    ap7 = function(fa) {
      return function(fab) {
        return isNone2(fab) ? none2 : isNone2(fa) ? none2 : some3(fab.value(fa.value));
      };
    };
    Apply6 = {
      URI: URI7,
      map: _map7,
      ap: _ap6
    };
    Applicative4 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6
    };
    chain6 = function(f) {
      return function(ma) {
        return isNone2(ma) ? none2 : f(ma.value);
      };
    };
    Chain6 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      chain: _chain6
    };
    Monad4 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      chain: _chain6
    };
    reduce6 = function(b, f) {
      return function(fa) {
        return isNone2(fa) ? b : f(b, fa.value);
      };
    };
    foldMap6 = function(M) {
      return function(f) {
        return function(fa) {
          return isNone2(fa) ? M.empty : f(fa.value);
        };
      };
    };
    reduceRight6 = function(b, f) {
      return function(fa) {
        return isNone2(fa) ? b : f(fa.value, b);
      };
    };
    Foldable4 = {
      URI: URI7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5
    };
    altW4 = function(that) {
      return function(fa) {
        return isNone2(fa) ? that() : fa;
      };
    };
    alt4 = altW4;
    Alt4 = {
      URI: URI7,
      map: _map7,
      alt: _alt4
    };
    zero3 = function() {
      return none2;
    };
    Zero3 = {
      URI: URI7,
      zero: zero3
    };
    guard4 = guard(Zero3, Pointed5);
    Alternative2 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      alt: _alt4,
      zero: zero3
    };
    extend6 = function(f) {
      return function(wa) {
        return isNone2(wa) ? none2 : some3(f(wa));
      };
    };
    Extend3 = {
      URI: URI7,
      map: _map7,
      extend: _extend4
    };
    compact3 = chain6(identity);
    defaultSeparated = separated(none2, none2);
    separate3 = function(ma) {
      return isNone2(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));
    };
    Compactable3 = {
      URI: URI7,
      compact: compact3,
      separate: separate3
    };
    filter4 = function(predicate) {
      return function(fa) {
        return isNone2(fa) ? none2 : predicate(fa.value) ? fa : none2;
      };
    };
    filterMap3 = function(f) {
      return function(fa) {
        return isNone2(fa) ? none2 : f(fa.value);
      };
    };
    partition3 = function(predicate) {
      return function(fa) {
        return separated(_filter3(fa, not(predicate)), _filter3(fa, predicate));
      };
    };
    partitionMap3 = function(f) {
      return flow(map7(f), separate3);
    };
    Filterable2 = {
      URI: URI7,
      map: _map7,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3
    };
    traverse5 = function(F) {
      return function(f) {
        return function(ta) {
          return isNone2(ta) ? F.of(none2) : F.map(f(ta.value), some3);
        };
      };
    };
    sequence5 = function(F) {
      return function(ta) {
        return isNone2(ta) ? F.of(none2) : F.map(ta.value, some3);
      };
    };
    Traversable5 = {
      URI: URI7,
      map: _map7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5
    };
    _wither3 = witherDefault(Traversable5, Compactable3);
    _wilt3 = wiltDefault(Traversable5, Compactable3);
    wither2 = function(F) {
      var _witherF = _wither3(F);
      return function(f) {
        return function(fa) {
          return _witherF(fa, f);
        };
      };
    };
    wilt2 = function(F) {
      var _wiltF = _wilt3(F);
      return function(f) {
        return function(fa) {
          return _wiltF(fa, f);
        };
      };
    };
    Witherable3 = {
      URI: URI7,
      map: _map7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3,
      wither: _wither3,
      wilt: _wilt3
    };
    throwError2 = function() {
      return none2;
    };
    MonadThrow2 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      chain: _chain6,
      throwError: throwError2
    };
    fromEither3 = getRight;
    FromEither4 = {
      URI: URI7,
      fromEither: fromEither3
    };
    isSome2 = isSome;
    isNone2 = function(fa) {
      return fa._tag === "None";
    };
    matchW4 = function(onNone, onSome) {
      return function(ma) {
        return isNone2(ma) ? onNone() : onSome(ma.value);
      };
    };
    foldW2 = matchW4;
    match4 = matchW4;
    fold3 = match4;
    getOrElseW2 = function(onNone) {
      return function(ma) {
        return isNone2(ma) ? onNone() : ma.value;
      };
    };
    getOrElse2 = getOrElseW2;
    flap8 = flap(Functor7);
    apFirst7 = apFirst(Apply6);
    apSecond7 = apSecond(Apply6);
    flatten6 = compact3;
    chainFirst7 = chainFirst(Chain6);
    duplicate6 = extend6(identity);
    fromEitherK4 = fromEitherK(FromEither4);
    chainEitherK2 = chainEitherK(FromEither4, Chain6);
    chainFirstEitherK2 = chainFirstEitherK(FromEither4, Chain6);
    fromNullable2 = function(a) {
      return a == null ? none2 : some3(a);
    };
    tryCatch2 = function(f) {
      try {
        return some3(f());
      } catch (e) {
        return none2;
      }
    };
    tryCatchK2 = function(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return tryCatch2(function() {
          return f.apply(void 0, a);
        });
      };
    };
    fromNullableK2 = function(f) {
      return flow(f, fromNullable2);
    };
    chainNullableK2 = function(f) {
      return function(ma) {
        return isNone2(ma) ? none2 : fromNullable2(f(ma.value));
      };
    };
    toNullable = match4(constNull, identity);
    toUndefined = match4(constUndefined, identity);
    exists3 = function(predicate) {
      return function(ma) {
        return isNone2(ma) ? false : predicate(ma.value);
      };
    };
    Do6 = of6(emptyRecord);
    bindTo7 = bindTo(Functor7);
    let_7 = let_(Functor7);
    bind7 = bind(Chain6);
    apS7 = apS(Apply6);
    ApT2 = of6(emptyReadonlyArray);
    traverseReadonlyNonEmptyArrayWithIndex2 = function(f) {
      return function(as) {
        var o = f(0, head(as));
        if (isNone2(o)) {
          return none2;
        }
        var out = [o.value];
        for (var i = 1; i < as.length; i++) {
          var o_1 = f(i, as[i]);
          if (isNone2(o_1)) {
            return none2;
          }
          out.push(o_1.value);
        }
        return some3(out);
      };
    };
    traverseReadonlyArrayWithIndex2 = function(f) {
      var g = traverseReadonlyNonEmptyArrayWithIndex2(f);
      return function(as) {
        return isNonEmpty(as) ? g(as) : ApT2;
      };
    };
    traverseArrayWithIndex2 = traverseReadonlyArrayWithIndex2;
    traverseArray2 = function(f) {
      return traverseReadonlyArrayWithIndex2(function(_, a) {
        return f(a);
      });
    };
    sequenceArray2 = traverseArray2(identity);
    mapNullable = chainNullableK2;
    option = {
      URI: URI7,
      map: _map7,
      of: of6,
      ap: _ap6,
      chain: _chain6,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5,
      zero: zero3,
      alt: _alt4,
      extend: _extend4,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3,
      wither: _wither3,
      wilt: _wilt3,
      throwError: throwError2
    };
    getApplySemigroup3 = getApplySemigroup(Apply6);
    getApplyMonoid2 = getApplicativeMonoid(Applicative4);
    getFirstMonoid = function() {
      return getMonoid3(first());
    };
    getLastMonoid = function() {
      return getMonoid3(last());
    };
  }
});

// node_modules/fp-ts/es6/string.js
var Eq2, Semigroup, empty4, Monoid, Ord2;
var init_string = __esm({
  "node_modules/fp-ts/es6/string.js"() {
    init_shim();
    init_ReadonlyNonEmptyArray();
    Eq2 = {
      equals: function(first2, second) {
        return first2 === second;
      }
    };
    Semigroup = {
      concat: function(first2, second) {
        return first2 + second;
      }
    };
    empty4 = "";
    Monoid = {
      concat: Semigroup.concat,
      empty: empty4
    };
    Ord2 = {
      equals: Eq2.equals,
      compare: function(first2, second) {
        return first2 < second ? -1 : first2 > second ? 1 : 0;
      }
    };
  }
});

// node_modules/fp-ts/es6/ReadonlyRecord.js
function collect(O) {
  if (typeof O === "function") {
    return collect(Ord2)(O);
  }
  var keysO = keys_(O);
  return function(f) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f(key, r[key]));
      }
      return out;
    };
  };
}
function isSubrecord(E) {
  return function(me, that) {
    if (that === void 0) {
      var isSubrecordE_1 = isSubrecord(E);
      return function(that2) {
        return isSubrecordE_1(that2, me);
      };
    }
    for (var k in me) {
      if (!has.call(that, k) || !E.equals(me[k], that[k])) {
        return false;
      }
    }
    return true;
  };
}
function lookup3(k, r) {
  if (r === void 0) {
    return function(r2) {
      return lookup3(k, r2);
    };
  }
  return has.call(r, k) ? some(r[k]) : none;
}
function mapWithIndex4(f) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        out[k] = f(k, r[k]);
      }
    }
    return out;
  };
}
function map8(f) {
  return mapWithIndex4(function(_, a) {
    return f(a);
  });
}
function reduceWithIndex5() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 2) {
    return reduceWithIndex5(Ord2).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b, f) {
    return function(fa) {
      var out = b;
      var ks = keysO(fa);
      var len = ks.length;
      for (var i = 0; i < len; i++) {
        var k = ks[i];
        out = f(k, out, fa[k]);
      }
      return out;
    };
  };
}
function foldMapWithIndex5(O) {
  if ("compare" in O) {
    var keysO_1 = keys_(O);
    return function(M) {
      return function(f) {
        return function(fa) {
          var out = M.empty;
          var ks = keysO_1(fa);
          var len = ks.length;
          for (var i = 0; i < len; i++) {
            var k = ks[i];
            out = M.concat(out, f(k, fa[k]));
          }
          return out;
        };
      };
    };
  }
  return foldMapWithIndex5(Ord2)(O);
}
function reduceRightWithIndex5() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 2) {
    return reduceRightWithIndex5(Ord2).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b, f) {
    return function(fa) {
      var out = b;
      var ks = keysO(fa);
      var len = ks.length;
      for (var i = len - 1; i >= 0; i--) {
        var k = ks[i];
        out = f(k, fa[k], out);
      }
      return out;
    };
  };
}
function traverseWithIndex4(F) {
  var traverseWithIndexOF = _traverseWithIndex3(Ord2)(F);
  return function(f) {
    return function(ta) {
      return traverseWithIndexOF(ta, f);
    };
  };
}
function traverse6(F) {
  var traverseOF = _traverse6(Ord2)(F);
  return function(f) {
    return function(ta) {
      return traverseOF(ta, f);
    };
  };
}
function sequence6(F) {
  return _sequence(Ord2)(F);
}
function partitionMapWithIndex3(f) {
  return function(r) {
    var left4 = {};
    var right4 = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var e = f(k, r[k]);
        switch (e._tag) {
          case "Left":
            left4[k] = e.left;
            break;
          case "Right":
            right4[k] = e.right;
            break;
        }
      }
    }
    return separated(left4, right4);
  };
}
function partitionWithIndex3(predicateWithIndex) {
  return function(r) {
    var left4 = {};
    var right4 = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var a = r[k];
        if (predicateWithIndex(k, a)) {
          right4[k] = a;
        } else {
          left4[k] = a;
        }
      }
    }
    return separated(left4, right4);
  };
}
function filterMapWithIndex3(f) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var ob = f(k, r[k]);
        if (isSome(ob)) {
          out[k] = ob.value;
        }
      }
    }
    return out;
  };
}
function filterWithIndex3(predicateWithIndex) {
  return function(fa) {
    var out = {};
    var changed = false;
    for (var key in fa) {
      if (has.call(fa, key)) {
        var a = fa[key];
        if (predicateWithIndex(key, a)) {
          out[key] = a;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa;
  };
}
function fromFoldable(M, F) {
  var fromFoldableMapM = fromFoldableMap(M, F);
  return function(fka) {
    return fromFoldableMapM(fka, identity);
  };
}
function fromFoldableMap(M, F) {
  return function(ta, f) {
    return F.reduce(ta, {}, function(r, a) {
      var _a = f(a), k = _a[0], b = _a[1];
      r[k] = has.call(r, k) ? M.concat(r[k], b) : b;
      return r;
    });
  };
}
function every3(predicate) {
  return function(r) {
    for (var k in r) {
      if (!predicate(r[k])) {
        return false;
      }
    }
    return true;
  };
}
function some4(predicate) {
  return function(r) {
    for (var k in r) {
      if (predicate(r[k])) {
        return true;
      }
    }
    return false;
  };
}
function elem5(E) {
  return function(a, fa) {
    if (fa === void 0) {
      var elemE_1 = elem5(E);
      return function(fa2) {
        return elemE_1(a, fa2);
      };
    }
    for (var k in fa) {
      if (E.equals(fa[k], a)) {
        return true;
      }
    }
    return false;
  };
}
function reduce7() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 1) {
    var reduceWithIndexO_1 = reduceWithIndex5(args[0]);
    return function(b, f) {
      return reduceWithIndexO_1(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
  }
  return reduce7(Ord2).apply(void 0, args);
}
function foldMap7(O) {
  if ("compare" in O) {
    var foldMapWithIndexO_1 = foldMapWithIndex5(O);
    return function(M) {
      var foldMapWithIndexM = foldMapWithIndexO_1(M);
      return function(f) {
        return foldMapWithIndexM(function(_, a) {
          return f(a);
        });
      };
    };
  }
  return foldMap7(Ord2)(O);
}
function reduceRight7() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 1) {
    var reduceRightWithIndexO_1 = reduceRightWithIndex5(args[0]);
    return function(b, f) {
      return reduceRightWithIndexO_1(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
  }
  return reduceRight7(Ord2).apply(void 0, args);
}
function getShow7(O) {
  if ("compare" in O) {
    return function(S) {
      return {
        show: function(r) {
          var elements = collect(O)(function(k, a) {
            return "".concat(JSON.stringify(k), ": ").concat(S.show(a));
          })(r).join(", ");
          return elements === "" ? "{}" : "{ ".concat(elements, " }");
        }
      };
    };
  }
  return getShow7(Ord2)(O);
}
function getEq7(E) {
  var isSubrecordE = isSubrecord(E);
  return fromEquals(function(x, y) {
    return isSubrecordE(x)(y) && isSubrecordE(y)(x);
  });
}
function getMonoid4(S) {
  return {
    concat: function(first2, second) {
      if (isEmpty3(first2)) {
        return second;
      }
      if (isEmpty3(second)) {
        return first2;
      }
      var r = Object.assign({}, first2);
      for (var k in second) {
        if (has.call(second, k)) {
          r[k] = has.call(first2, k) ? S.concat(first2[k], second[k]) : second[k];
        }
      }
      return r;
    },
    empty: empty5
  };
}
function hasOwnProperty2(k, r) {
  return has.call(r === void 0 ? this : r, k);
}
var size2, isEmpty3, keys_, keys, toReadonlyArray, upsertAt, has2, empty5, singleton2, union5, intersection3, difference2, _map8, _mapWithIndex3, _reduce6, _foldMap6, _reduceRight6, _filter4, _filterMap4, _partition4, _partitionMap4, _reduceWithIndex3, _foldMapWithIndex3, _reduceRightWithIndex3, _partitionMapWithIndex2, _partitionWithIndex2, _filterMapWithIndex2, _filterWithIndex2, _traverse6, _sequence, _traverseWithIndex3, filter5, filterMap4, partition4, partitionMap4, compact4, separate4, URI8, Functor8, flap9, Compactable4, Foldable5, FoldableWithIndex3, Traversable6, TraversableWithIndex3, _wither4, _wilt4, Witherable4, readonlyRecord;
var init_ReadonlyRecord = __esm({
  "node_modules/fp-ts/es6/ReadonlyRecord.js"() {
    init_shim();
    init_Eq();
    init_function();
    init_Functor();
    init_internal();
    init_Separated();
    init_string();
    init_Witherable();
    size2 = function(r) {
      return Object.keys(r).length;
    };
    isEmpty3 = function(r) {
      for (var k in r) {
        if (has.call(r, k)) {
          return false;
        }
      }
      return true;
    };
    keys_ = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    keys = keys_(Ord2);
    toReadonlyArray = collect(Ord2)(function(k, a) {
      return [k, a];
    });
    upsertAt = function(k, a) {
      return function(r) {
        if (has.call(r, k) && r[k] === a) {
          return r;
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return out;
      };
    };
    has2 = function(k, r) {
      return has.call(r, k);
    };
    empty5 = {};
    singleton2 = function(k, a) {
      var _a;
      return _a = {}, _a[k] = a, _a;
    };
    union5 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty3(first2)) {
            return second;
          }
          if (isEmpty3(second)) {
            return first2;
          }
          var out = {};
          for (var k in first2) {
            if (has2(k, second)) {
              out[k] = M.concat(first2[k], second[k]);
            } else {
              out[k] = first2[k];
            }
          }
          for (var k in second) {
            if (!has2(k, out)) {
              out[k] = second[k];
            }
          }
          return out;
        };
      };
    };
    intersection3 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty3(first2) || isEmpty3(second)) {
            return empty5;
          }
          var out = {};
          for (var k in first2) {
            if (has2(k, second)) {
              out[k] = M.concat(first2[k], second[k]);
            }
          }
          return out;
        };
      };
    };
    difference2 = function(second) {
      return function(first2) {
        if (isEmpty3(first2)) {
          return second;
        }
        if (isEmpty3(second)) {
          return first2;
        }
        var out = {};
        for (var k in first2) {
          if (!has2(k, second)) {
            out[k] = first2[k];
          }
        }
        for (var k in second) {
          if (!has2(k, first2)) {
            out[k] = second[k];
          }
        }
        return out;
      };
    };
    _map8 = function(fa, f) {
      return pipe(fa, map8(f));
    };
    _mapWithIndex3 = function(fa, f) {
      return pipe(fa, mapWithIndex4(f));
    };
    _reduce6 = function(O) {
      var reduceO = reduce7(O);
      return function(fa, b, f) {
        return pipe(fa, reduceO(b, f));
      };
    };
    _foldMap6 = function(O) {
      return function(M) {
        var foldMapM = foldMap7(O)(M);
        return function(fa, f) {
          return pipe(fa, foldMapM(f));
        };
      };
    };
    _reduceRight6 = function(O) {
      var reduceRightO = reduceRight7(O);
      return function(fa, b, f) {
        return pipe(fa, reduceRightO(b, f));
      };
    };
    _filter4 = function(fa, predicate) {
      return pipe(fa, filter5(predicate));
    };
    _filterMap4 = function(fa, f) {
      return pipe(fa, filterMap4(f));
    };
    _partition4 = function(fa, predicate) {
      return pipe(fa, partition4(predicate));
    };
    _partitionMap4 = function(fa, f) {
      return pipe(fa, partitionMap4(f));
    };
    _reduceWithIndex3 = function(O) {
      var reduceWithIndexO = reduceWithIndex5(O);
      return function(fa, b, f) {
        return pipe(fa, reduceWithIndexO(b, f));
      };
    };
    _foldMapWithIndex3 = function(O) {
      var foldMapWithIndexO = foldMapWithIndex5(O);
      return function(M) {
        var foldMapWithIndexM = foldMapWithIndexO(M);
        return function(fa, f) {
          return pipe(fa, foldMapWithIndexM(f));
        };
      };
    };
    _reduceRightWithIndex3 = function(O) {
      var reduceRightWithIndexO = reduceRightWithIndex5(O);
      return function(fa, b, f) {
        return pipe(fa, reduceRightWithIndexO(b, f));
      };
    };
    _partitionMapWithIndex2 = function(fa, f) {
      return pipe(fa, partitionMapWithIndex3(f));
    };
    _partitionWithIndex2 = function(fa, predicateWithIndex) {
      return pipe(fa, partitionWithIndex3(predicateWithIndex));
    };
    _filterMapWithIndex2 = function(fa, f) {
      return pipe(fa, filterMapWithIndex3(f));
    };
    _filterWithIndex2 = function(fa, predicateWithIndex) {
      return pipe(fa, filterWithIndex3(predicateWithIndex));
    };
    _traverse6 = function(O) {
      var traverseWithIndexO = _traverseWithIndex3(O);
      return function(F) {
        var traverseWithIndexOF = traverseWithIndexO(F);
        return function(ta, f) {
          return traverseWithIndexOF(ta, flow(SK, f));
        };
      };
    };
    _sequence = function(O) {
      var traverseO = _traverse6(O);
      return function(F) {
        var traverseOF = traverseO(F);
        return function(ta) {
          return traverseOF(ta, identity);
        };
      };
    };
    _traverseWithIndex3 = function(O) {
      return function(F) {
        var keysO = keys_(O);
        return function(ta, f) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of(empty5);
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                var _a;
                return Object.assign({}, r, (_a = {}, _a[key2] = b, _a));
              };
            }), f(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    filter5 = function(predicate) {
      return filterWithIndex3(function(_, a) {
        return predicate(a);
      });
    };
    filterMap4 = function(f) {
      return filterMapWithIndex3(function(_, a) {
        return f(a);
      });
    };
    partition4 = function(predicate) {
      return partitionWithIndex3(function(_, a) {
        return predicate(a);
      });
    };
    partitionMap4 = function(f) {
      return partitionMapWithIndex3(function(_, a) {
        return f(a);
      });
    };
    compact4 = function(r) {
      var out = {};
      for (var k in r) {
        if (has.call(r, k)) {
          var oa = r[k];
          if (isSome(oa)) {
            out[k] = oa.value;
          }
        }
      }
      return out;
    };
    separate4 = function(r) {
      var left4 = {};
      var right4 = {};
      for (var k in r) {
        if (has.call(r, k)) {
          var e = r[k];
          if (isLeft(e)) {
            left4[k] = e.left;
          } else {
            right4[k] = e.right;
          }
        }
      }
      return separated(left4, right4);
    };
    URI8 = "ReadonlyRecord";
    Functor8 = {
      URI: URI8,
      map: _map8
    };
    flap9 = flap(Functor8);
    Compactable4 = {
      URI: URI8,
      compact: compact4,
      separate: separate4
    };
    Foldable5 = {
      URI: URI8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2)
    };
    FoldableWithIndex3 = {
      URI: URI8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2)
    };
    Traversable6 = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6
    };
    TraversableWithIndex3 = {
      URI: URI8,
      map: _map8,
      mapWithIndex: _mapWithIndex3,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      traverseWithIndex: _traverseWithIndex3(Ord2)
    };
    _wither4 = witherDefault(Traversable6, Compactable4);
    _wilt4 = wiltDefault(Traversable6, Compactable4);
    Witherable4 = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      compact: compact4,
      separate: separate4,
      filter: _filter4,
      filterMap: _filterMap4,
      partition: _partition4,
      partitionMap: _partitionMap4,
      wither: _wither4,
      wilt: _wilt4
    };
    readonlyRecord = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      compact: compact4,
      separate: separate4,
      filter: _filter4,
      filterMap: _filterMap4,
      partition: _partition4,
      partitionMap: _partitionMap4,
      mapWithIndex: _mapWithIndex3,
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2),
      filterMapWithIndex: _filterMapWithIndex2,
      filterWithIndex: _filterWithIndex2,
      partitionMapWithIndex: _partitionMapWithIndex2,
      partitionWithIndex: _partitionWithIndex2,
      traverseWithIndex: _traverseWithIndex3(Ord2),
      wither: _wither4,
      wilt: _wilt4
    };
  }
});

// node_modules/fp-ts/es6/Record.js
var Record_exports = {};
__export(Record_exports, {
  Compactable: () => Compactable5,
  Filterable: () => Filterable3,
  FilterableWithIndex: () => FilterableWithIndex2,
  Foldable: () => Foldable6,
  FoldableWithIndex: () => FoldableWithIndex4,
  Functor: () => Functor9,
  FunctorWithIndex: () => FunctorWithIndex3,
  Traversable: () => Traversable7,
  TraversableWithIndex: () => TraversableWithIndex4,
  URI: () => URI9,
  Witherable: () => Witherable5,
  collect: () => collect2,
  compact: () => compact5,
  deleteAt: () => deleteAt2,
  difference: () => difference3,
  elem: () => elem6,
  empty: () => empty6,
  every: () => every4,
  filter: () => filter6,
  filterMap: () => filterMap5,
  filterMapWithIndex: () => filterMapWithIndex4,
  filterWithIndex: () => filterWithIndex4,
  flap: () => flap10,
  foldMap: () => foldMap8,
  foldMapWithIndex: () => foldMapWithIndex6,
  fromEntries: () => fromEntries,
  fromFoldable: () => fromFoldable2,
  fromFoldableMap: () => fromFoldableMap2,
  getDifferenceMagma: () => getDifferenceMagma2,
  getEq: () => getEq8,
  getFoldable: () => getFoldable,
  getFoldableWithIndex: () => getFoldableWithIndex,
  getIntersectionSemigroup: () => getIntersectionSemigroup2,
  getMonoid: () => getMonoid5,
  getShow: () => getShow8,
  getTraversable: () => getTraversable,
  getTraversableWithIndex: () => getTraversableWithIndex,
  getUnionMonoid: () => getUnionMonoid2,
  getUnionSemigroup: () => getUnionSemigroup3,
  getWitherable: () => getWitherable2,
  has: () => has3,
  hasOwnProperty: () => hasOwnProperty3,
  insertAt: () => insertAt3,
  intersection: () => intersection4,
  isEmpty: () => isEmpty4,
  isSubrecord: () => isSubrecord2,
  keys: () => keys2,
  lookup: () => lookup4,
  map: () => map9,
  mapWithIndex: () => mapWithIndex5,
  modifyAt: () => modifyAt3,
  partition: () => partition5,
  partitionMap: () => partitionMap5,
  partitionMapWithIndex: () => partitionMapWithIndex4,
  partitionWithIndex: () => partitionWithIndex4,
  pop: () => pop,
  record: () => record2,
  reduce: () => reduce8,
  reduceRight: () => reduceRight8,
  reduceRightWithIndex: () => reduceRightWithIndex6,
  reduceWithIndex: () => reduceWithIndex6,
  separate: () => separate5,
  sequence: () => sequence7,
  singleton: () => singleton3,
  size: () => size3,
  some: () => some5,
  toArray: () => toArray,
  toEntries: () => toEntries,
  toUnfoldable: () => toUnfoldable,
  traverse: () => traverse7,
  traverseWithIndex: () => traverseWithIndex5,
  union: () => union6,
  updateAt: () => updateAt3,
  upsertAt: () => upsertAt2,
  wilt: () => wilt3,
  wither: () => wither3
});
function collect2(O) {
  if (typeof O === "function") {
    return collect2(Ord2)(O);
  }
  var keysO = keys_2(O);
  return function(f) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f(key, r[key]));
      }
      return out;
    };
  };
}
function toUnfoldable(U) {
  return function(r) {
    var sas = toArray(r);
    var len = sas.length;
    return U.unfold(0, function(b) {
      return b < len ? some([sas[b], b + 1]) : none;
    });
  };
}
function deleteAt2(k) {
  return function(r) {
    if (!has.call(r, k)) {
      return r;
    }
    var out = Object.assign({}, r);
    delete out[k];
    return out;
  };
}
function pop(k) {
  var deleteAtk = deleteAt2(k);
  return function(r) {
    var oa = lookup4(k, r);
    return isNone(oa) ? none : some([oa.value, deleteAtk(r)]);
  };
}
function reduceWithIndex6() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceWithIndex5(args[0]) : reduceWithIndex5(Ord2).apply(void 0, args);
}
function foldMapWithIndex6(O) {
  return "compare" in O ? foldMapWithIndex5(O) : foldMapWithIndex5(Ord2)(O);
}
function reduceRightWithIndex6() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceRightWithIndex5(args[0]) : reduceRightWithIndex5(Ord2).apply(void 0, args);
}
function traverseWithIndex5(F) {
  return traverseWithIndex4(F);
}
function traverse7(F) {
  return traverse6(F);
}
function sequence7(F) {
  return sequence6(F);
}
function partitionWithIndex4(predicateWithIndex) {
  return partitionWithIndex3(predicateWithIndex);
}
function filterWithIndex4(predicateWithIndex) {
  return filterWithIndex3(predicateWithIndex);
}
function fromFoldable2(M, F) {
  return fromFoldable(M, F);
}
function fromFoldableMap2(M, F) {
  return fromFoldableMap(M, F);
}
function reduce8() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduce7(args[0]) : reduce7(Ord2).apply(void 0, args);
}
function foldMap8(O) {
  return "compare" in O ? foldMap7(O) : foldMap7(Ord2)(O);
}
function reduceRight8() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceRight7(args[0]) : reduceRight7(Ord2).apply(void 0, args);
}
function getShow8(O) {
  return "compare" in O ? getShow7(O) : getShow7(Ord2)(O);
}
var __assign2, size3, isEmpty4, keys_2, keys2, toArray, upsertAt2, has3, updateAt3, modifyAt3, isSubrecord2, lookup4, mapWithIndex5, map9, singleton3, wither3, wilt3, partitionMapWithIndex4, filterMapWithIndex4, toEntries, fromEntries, every4, some5, elem6, union6, intersection4, difference3, _map9, _mapWithIndex4, _reduce7, _foldMap7, _reduceRight7, _filter5, _filterMap5, _partition5, _partitionMap5, _reduceWithIndex4, _foldMapWithIndex4, _reduceRightWithIndex4, _partitionMapWithIndex3, _partitionWithIndex3, _filterMapWithIndex3, _filterWithIndex3, _traverse7, _sequence2, _traverseWithIndex4, filter6, filterMap5, partition5, partitionMap5, compact5, separate5, URI9, getEq8, getMonoid5, Functor9, flap10, FunctorWithIndex3, getFoldable, getFoldableWithIndex, Compactable5, Filterable3, FilterableWithIndex2, getTraversable, getTraversableWithIndex, getWitherable2, getUnionSemigroup3, getUnionMonoid2, getIntersectionSemigroup2, getDifferenceMagma2, Foldable6, FoldableWithIndex4, Traversable7, TraversableWithIndex4, _wither5, _wilt5, Witherable5, empty6, insertAt3, hasOwnProperty3, record2;
var init_Record = __esm({
  "node_modules/fp-ts/es6/Record.js"() {
    init_shim();
    init_Array();
    init_function();
    init_Functor();
    init_internal();
    init_ReadonlyRecord();
    init_Semigroup();
    init_string();
    init_Witherable();
    __assign2 = function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    size3 = size2;
    isEmpty4 = isEmpty3;
    keys_2 = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    keys2 = keys_2(Ord2);
    toArray = collect2(Ord2)(function(k, a) {
      return [
        k,
        a
      ];
    });
    upsertAt2 = upsertAt;
    has3 = has2;
    updateAt3 = function(k, a) {
      return modifyAt3(k, function() {
        return a;
      });
    };
    modifyAt3 = function(k, f) {
      return function(r) {
        if (!has3(k, r)) {
          return none;
        }
        var out = Object.assign({}, r);
        out[k] = f(r[k]);
        return some(out);
      };
    };
    isSubrecord2 = isSubrecord;
    lookup4 = lookup3;
    mapWithIndex5 = mapWithIndex4;
    map9 = map8;
    singleton3 = singleton2;
    wither3 = function(F) {
      var traverseF = traverse7(F);
      return function(f) {
        return function(fa) {
          return F.map(pipe(fa, traverseF(f)), compact5);
        };
      };
    };
    wilt3 = function(F) {
      var traverseF = traverse7(F);
      return function(f) {
        return function(fa) {
          return F.map(pipe(fa, traverseF(f)), separate5);
        };
      };
    };
    partitionMapWithIndex4 = partitionMapWithIndex3;
    filterMapWithIndex4 = filterMapWithIndex3;
    toEntries = toArray;
    fromEntries = function(fa) {
      return fromFoldable2(last(), Foldable3)(fa);
    };
    every4 = every3;
    some5 = some4;
    elem6 = elem5;
    union6 = function(M) {
      var unionM = union5(M);
      return function(second) {
        return function(first2) {
          if (isEmpty4(first2)) {
            return __assign2({}, second);
          }
          if (isEmpty4(second)) {
            return __assign2({}, first2);
          }
          return unionM(second)(first2);
        };
      };
    };
    intersection4 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty4(first2) || isEmpty4(second)) {
            return {};
          }
          return intersection3(M)(second)(first2);
        };
      };
    };
    difference3 = function(second) {
      return function(first2) {
        if (isEmpty4(first2)) {
          return __assign2({}, second);
        }
        if (isEmpty4(second)) {
          return __assign2({}, first2);
        }
        return difference2(second)(first2);
      };
    };
    _map9 = _map8;
    _mapWithIndex4 = _mapWithIndex3;
    _reduce7 = _reduce6;
    _foldMap7 = _foldMap6;
    _reduceRight7 = _reduceRight6;
    _filter5 = _filter4;
    _filterMap5 = _filterMap4;
    _partition5 = _partition4;
    _partitionMap5 = _partitionMap4;
    _reduceWithIndex4 = _reduceWithIndex3;
    _foldMapWithIndex4 = _foldMapWithIndex3;
    _reduceRightWithIndex4 = _reduceRightWithIndex3;
    _partitionMapWithIndex3 = _partitionMapWithIndex2;
    _partitionWithIndex3 = _partitionWithIndex2;
    _filterMapWithIndex3 = _filterMapWithIndex2;
    _filterWithIndex3 = _filterWithIndex2;
    _traverse7 = _traverse6;
    _sequence2 = _sequence;
    _traverseWithIndex4 = function(O) {
      return function(F) {
        var keysO = keys_2(O);
        return function(ta, f) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of({});
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                r[key2] = b;
                return r;
              };
            }), f(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    filter6 = filter5;
    filterMap5 = filterMap4;
    partition5 = partition4;
    partitionMap5 = partitionMap4;
    compact5 = compact4;
    separate5 = separate4;
    URI9 = "Record";
    getEq8 = getEq7;
    getMonoid5 = getMonoid4;
    Functor9 = {
      URI: URI9,
      map: _map9
    };
    flap10 = flap(Functor9);
    FunctorWithIndex3 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4
    };
    getFoldable = function(O) {
      return {
        URI: URI9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O)
      };
    };
    getFoldableWithIndex = function(O) {
      return {
        URI: URI9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        reduceWithIndex: _reduceWithIndex4(O),
        foldMapWithIndex: _foldMapWithIndex4(O),
        reduceRightWithIndex: _reduceRightWithIndex4(O)
      };
    };
    Compactable5 = {
      URI: URI9,
      compact: compact5,
      separate: separate5
    };
    Filterable3 = {
      URI: URI9,
      map: _map9,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5
    };
    FilterableWithIndex2 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      filterMapWithIndex: _filterMapWithIndex3,
      filterWithIndex: _filterWithIndex3,
      partitionMapWithIndex: _partitionMapWithIndex3,
      partitionWithIndex: _partitionWithIndex3
    };
    getTraversable = function(O) {
      return {
        URI: URI9,
        map: _map9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        traverse: _traverse7(O),
        sequence: _sequence2(O)
      };
    };
    getTraversableWithIndex = function(O) {
      return {
        URI: URI9,
        map: _map9,
        mapWithIndex: _mapWithIndex4,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        reduceWithIndex: _reduceWithIndex4(O),
        foldMapWithIndex: _foldMapWithIndex4(O),
        reduceRightWithIndex: _reduceRightWithIndex4(O),
        traverse: _traverse7(O),
        sequence: _sequence2(O),
        traverseWithIndex: _traverseWithIndex4(O)
      };
    };
    getWitherable2 = function(O) {
      var T = getTraversable(O);
      return {
        URI: URI9,
        map: _map9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        traverse: T.traverse,
        sequence: T.sequence,
        compact: compact5,
        separate: separate5,
        filter: _filter5,
        filterMap: _filterMap5,
        partition: _partition5,
        partitionMap: _partitionMap5,
        wither: witherDefault(T, Compactable5),
        wilt: wiltDefault(T, Compactable5)
      };
    };
    getUnionSemigroup3 = function(S) {
      var unionS = union6(S);
      return {
        concat: function(first2, second) {
          return unionS(second)(first2);
        }
      };
    };
    getUnionMonoid2 = function(S) {
      return {
        concat: getUnionSemigroup3(S).concat,
        empty: {}
      };
    };
    getIntersectionSemigroup2 = function(S) {
      var intersectionS = intersection4(S);
      return {
        concat: function(first2, second) {
          return intersectionS(second)(first2);
        }
      };
    };
    getDifferenceMagma2 = function() {
      return {
        concat: function(first2, second) {
          return difference3(second)(first2);
        }
      };
    };
    Foldable6 = {
      URI: URI9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2)
    };
    FoldableWithIndex4 = {
      URI: URI9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2)
    };
    Traversable7 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7
    };
    TraversableWithIndex4 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      traverseWithIndex: _traverseWithIndex4(Ord2)
    };
    _wither5 = witherDefault(Traversable7, Compactable5);
    _wilt5 = wiltDefault(Traversable7, Compactable5);
    Witherable5 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      wither: _wither5,
      wilt: _wilt5
    };
    empty6 = {};
    insertAt3 = upsertAt2;
    hasOwnProperty3 = hasOwnProperty2;
    record2 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      mapWithIndex: _mapWithIndex4,
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2),
      filterMapWithIndex: _filterMapWithIndex3,
      filterWithIndex: _filterWithIndex3,
      partitionMapWithIndex: _partitionMapWithIndex3,
      partitionWithIndex: _partitionWithIndex3,
      traverseWithIndex: _traverseWithIndex4(Ord2),
      wither: _wither5,
      wilt: _wilt5
    };
  }
});

// node_modules/fp-ts/es6/pipeable.js
var pipeable_exports = {};
__export(pipeable_exports, {
  alt: () => alt5,
  ap: () => ap8,
  bimap: () => bimap2,
  chain: () => chain7,
  compose: () => compose,
  contramap: () => contramap2,
  extend: () => extend7,
  filter: () => filter7,
  filterMap: () => filterMap6,
  filterMapWithIndex: () => filterMapWithIndex5,
  filterWithIndex: () => filterWithIndex5,
  foldMap: () => foldMap9,
  foldMapWithIndex: () => foldMapWithIndex7,
  map: () => map10,
  mapLeft: () => mapLeft2,
  mapWithIndex: () => mapWithIndex6,
  partition: () => partition6,
  partitionMap: () => partitionMap6,
  partitionMapWithIndex: () => partitionMapWithIndex5,
  partitionWithIndex: () => partitionWithIndex5,
  pipe: () => pipe2,
  pipeable: () => pipeable,
  promap: () => promap,
  reduce: () => reduce9,
  reduceRight: () => reduceRight9,
  reduceRightWithIndex: () => reduceRightWithIndex7,
  reduceWithIndex: () => reduceWithIndex7
});
function map10(F) {
  return function(f) {
    return function(fa) {
      return F.map(fa, f);
    };
  };
}
function contramap2(F) {
  return function(f) {
    return function(fa) {
      return F.contramap(fa, f);
    };
  };
}
function mapWithIndex6(F) {
  return function(f) {
    return function(fa) {
      return F.mapWithIndex(fa, f);
    };
  };
}
function ap8(F) {
  return function(fa) {
    return function(fab) {
      return F.ap(fab, fa);
    };
  };
}
function chain7(F) {
  return function(f) {
    return function(fa) {
      return F.chain(fa, f);
    };
  };
}
function bimap2(F) {
  return function(f, g) {
    return function(fea) {
      return F.bimap(fea, f, g);
    };
  };
}
function mapLeft2(F) {
  return function(f) {
    return function(fea) {
      return F.mapLeft(fea, f);
    };
  };
}
function extend7(F) {
  return function(f) {
    return function(wa) {
      return F.extend(wa, f);
    };
  };
}
function reduce9(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduce(fa, b, f);
    };
  };
}
function foldMap9(F) {
  return function(M) {
    var foldMapM = F.foldMap(M);
    return function(f) {
      return function(fa) {
        return foldMapM(fa, f);
      };
    };
  };
}
function reduceRight9(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduceRight(fa, b, f);
    };
  };
}
function reduceWithIndex7(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduceWithIndex(fa, b, f);
    };
  };
}
function foldMapWithIndex7(F) {
  return function(M) {
    var foldMapWithIndexM = F.foldMapWithIndex(M);
    return function(f) {
      return function(fa) {
        return foldMapWithIndexM(fa, f);
      };
    };
  };
}
function reduceRightWithIndex7(F) {
  return function(b, f) {
    return function(fa) {
      return F.reduceRightWithIndex(fa, b, f);
    };
  };
}
function alt5(F) {
  return function(that) {
    return function(fa) {
      return F.alt(fa, that);
    };
  };
}
function filter7(F) {
  return function(predicate) {
    return function(fa) {
      return F.filter(fa, predicate);
    };
  };
}
function filterMap6(F) {
  return function(f) {
    return function(fa) {
      return F.filterMap(fa, f);
    };
  };
}
function partition6(F) {
  return function(f) {
    return function(fa) {
      return F.partition(fa, f);
    };
  };
}
function partitionMap6(F) {
  return function(f) {
    return function(fa) {
      return F.partitionMap(fa, f);
    };
  };
}
function filterWithIndex5(F) {
  return function(predicate) {
    return function(fa) {
      return F.filterWithIndex(fa, predicate);
    };
  };
}
function filterMapWithIndex5(F) {
  return function(f) {
    return function(fa) {
      return F.filterMapWithIndex(fa, f);
    };
  };
}
function partitionWithIndex5(F) {
  return function(f) {
    return function(fa) {
      return F.partitionWithIndex(fa, f);
    };
  };
}
function partitionMapWithIndex5(F) {
  return function(f) {
    return function(fa) {
      return F.partitionMapWithIndex(fa, f);
    };
  };
}
function promap(F) {
  return function(f, g) {
    return function(fbc) {
      return F.promap(fbc, f, g);
    };
  };
}
function compose(F) {
  return function(ea) {
    return function(ab) {
      return F.compose(ab, ea);
    };
  };
}
function pipeable(I) {
  var r = {};
  if (isFunctor(I)) {
    r.map = map10(I);
  }
  if (isContravariant(I)) {
    r.contramap = contramap2(I);
  }
  if (isFunctorWithIndex(I)) {
    r.mapWithIndex = mapWithIndex6(I);
  }
  if (isApply(I)) {
    r.ap = ap8(I);
    r.apFirst = apFirst(I);
    r.apSecond = apSecond(I);
  }
  if (isChain(I)) {
    r.chain = chain7(I);
    r.chainFirst = chainFirst(I);
    r.flatten = r.chain(identity);
  }
  if (isBifunctor(I)) {
    r.bimap = bimap2(I);
    r.mapLeft = mapLeft2(I);
  }
  if (isExtend(I)) {
    r.extend = extend7(I);
    r.duplicate = r.extend(identity);
  }
  if (isFoldable(I)) {
    r.reduce = reduce9(I);
    r.foldMap = foldMap9(I);
    r.reduceRight = reduceRight9(I);
  }
  if (isFoldableWithIndex(I)) {
    r.reduceWithIndex = reduceWithIndex7(I);
    r.foldMapWithIndex = foldMapWithIndex7(I);
    r.reduceRightWithIndex = reduceRightWithIndex7(I);
  }
  if (isAlt(I)) {
    r.alt = alt5(I);
  }
  if (isCompactable(I)) {
    r.compact = I.compact;
    r.separate = I.separate;
  }
  if (isFilterable(I)) {
    r.filter = filter7(I);
    r.filterMap = filterMap6(I);
    r.partition = partition6(I);
    r.partitionMap = partitionMap6(I);
  }
  if (isFilterableWithIndex(I)) {
    r.filterWithIndex = filterWithIndex5(I);
    r.filterMapWithIndex = filterMapWithIndex5(I);
    r.partitionWithIndex = partitionWithIndex5(I);
    r.partitionMapWithIndex = partitionMapWithIndex5(I);
  }
  if (isProfunctor(I)) {
    r.promap = promap(I);
  }
  if (isSemigroupoid(I)) {
    r.compose = compose(I);
  }
  if (isMonadThrow(I)) {
    var fromOption4 = function(onNone) {
      return function(ma) {
        return ma._tag === "None" ? I.throwError(onNone()) : I.of(ma.value);
      };
    };
    var fromEither4 = function(ma) {
      return ma._tag === "Left" ? I.throwError(ma.left) : I.of(ma.right);
    };
    var fromPredicate5 = function(predicate, onFalse) {
      return function(a) {
        return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
      };
    };
    var filterOrElse3 = function(predicate, onFalse) {
      return function(ma) {
        return I.chain(ma, function(a) {
          return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
        });
      };
    };
    r.fromOption = fromOption4;
    r.fromEither = fromEither4;
    r.fromPredicate = fromPredicate5;
    r.filterOrElse = filterOrElse3;
  }
  return r;
}
var isFunctor, isContravariant, isFunctorWithIndex, isApply, isChain, isBifunctor, isExtend, isFoldable, isFoldableWithIndex, isAlt, isCompactable, isFilterable, isFilterableWithIndex, isProfunctor, isSemigroupoid, isMonadThrow, pipe2;
var init_pipeable = __esm({
  "node_modules/fp-ts/es6/pipeable.js"() {
    init_shim();
    init_Apply();
    init_Chain();
    init_function();
    isFunctor = function(I) {
      return typeof I.map === "function";
    };
    isContravariant = function(I) {
      return typeof I.contramap === "function";
    };
    isFunctorWithIndex = function(I) {
      return typeof I.mapWithIndex === "function";
    };
    isApply = function(I) {
      return typeof I.ap === "function";
    };
    isChain = function(I) {
      return typeof I.chain === "function";
    };
    isBifunctor = function(I) {
      return typeof I.bimap === "function";
    };
    isExtend = function(I) {
      return typeof I.extend === "function";
    };
    isFoldable = function(I) {
      return typeof I.reduce === "function";
    };
    isFoldableWithIndex = function(I) {
      return typeof I.reduceWithIndex === "function";
    };
    isAlt = function(I) {
      return typeof I.alt === "function";
    };
    isCompactable = function(I) {
      return typeof I.compact === "function";
    };
    isFilterable = function(I) {
      return typeof I.filter === "function";
    };
    isFilterableWithIndex = function(I) {
      return typeof I.filterWithIndex === "function";
    };
    isProfunctor = function(I) {
      return typeof I.promap === "function";
    };
    isSemigroupoid = function(I) {
      return typeof I.compose === "function";
    };
    isMonadThrow = function(I) {
      return typeof I.throwError === "function";
    };
    pipe2 = pipe;
  }
});

// node_modules/io-ts-reporters/target/src/utils.js
var require_utils = __commonJS({
  "node_modules/io-ts-reporters/target/src/utils.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeUntil = void 0;
    var takeUntil = function(predicate) {
      return function(as) {
        var init4 = [];
        for (var i = 0; i < as.length; i++) {
          init4[i] = as[i];
          if (predicate(as[i])) {
            return init4;
          }
        }
        return init4;
      };
    };
    exports.takeUntil = takeUntil;
  }
});

// node_modules/io-ts-reporters/target/src/index.js
var require_src = __commonJS({
  "node_modules/io-ts-reporters/target/src/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reporter = exports.formatValidationErrors = exports.formatValidationError = exports.TYPE_MAX_LEN = void 0;
    var A = (init_Array(), __toCommonJS(Array_exports));
    var E = (init_Either(), __toCommonJS(Either_exports));
    var NEA = (init_NonEmptyArray(), __toCommonJS(NonEmptyArray_exports));
    var O = (init_Option(), __toCommonJS(Option_exports));
    var R = (init_Record(), __toCommonJS(Record_exports));
    var pipeable_1 = (init_pipeable(), __toCommonJS(pipeable_exports));
    var t = (init_es6(), __toCommonJS(es6_exports));
    var utils_1 = require_utils();
    var isUnionType = function(_a) {
      var type2 = _a.type;
      return type2 instanceof t.UnionType;
    };
    var jsToString = function(value) {
      return value === void 0 ? "undefined" : JSON.stringify(value);
    };
    var keyPath = function(ctx) {
      return ctx.map(function(c) {
        return c.key;
      }).filter(Boolean).join(".");
    };
    var getErrorFromCtx = function(validation) {
      return A.last(validation.context);
    };
    var getValidationContext = function(validation) {
      return validation.context;
    };
    exports.TYPE_MAX_LEN = 160;
    var truncateType = function(type2, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.truncateLongTypes, truncateLongTypes = _a === void 0 ? true : _a;
      if (truncateLongTypes && type2.length > exports.TYPE_MAX_LEN) {
        return type2.slice(0, exports.TYPE_MAX_LEN - 3) + "...";
      }
      return type2;
    };
    var errorMessageSimple = function(expectedType, path, error, options) {
      return [
        "Expecting " + truncateType(expectedType, options),
        path === "" ? "" : "at " + path,
        "but instead got: " + jsToString(error.value),
        error.message ? "(" + error.message + ")" : ""
      ].filter(Boolean).join(" ");
    };
    var errorMessageUnion = function(expectedTypes, path, value, options) {
      return [
        "Expecting one of:\n",
        expectedTypes.map(function(type2) {
          return "    " + truncateType(type2, options);
        }).join("\n"),
        path === "" ? "\n" : "\nat " + path + " ",
        "but instead got: " + jsToString(value)
      ].filter(Boolean).join("");
    };
    var findExpectedType = function(ctx) {
      return pipeable_1.pipe(ctx, A.findIndex(isUnionType), O.chain(function(n) {
        return A.lookup(n + 1, ctx);
      }));
    };
    var formatValidationErrorOfUnion = function(path, errors, options) {
      var expectedTypes = pipeable_1.pipe(errors, A.map(getValidationContext), A.map(findExpectedType), A.compact);
      var value = pipeable_1.pipe(expectedTypes, A.head, O.map(function(v) {
        return v.actual;
      }), O.getOrElse(function() {
        return void 0;
      }));
      var expected = expectedTypes.map(function(_a) {
        var type2 = _a.type;
        return type2.name;
      });
      return expected.length > 0 ? O.some(errorMessageUnion(expected, path, value, options)) : O.none;
    };
    var formatValidationCommonError = function(path, error, options) {
      return pipeable_1.pipe(error, getErrorFromCtx, O.map(function(errorContext) {
        return errorMessageSimple(errorContext.type.name, path, error, options);
      }));
    };
    var groupByKey = NEA.groupBy(function(error) {
      return pipeable_1.pipe(error.context, utils_1.takeUntil(isUnionType), keyPath);
    });
    var format = function(path, errors, options) {
      return NEA.tail(errors).length > 0 ? formatValidationErrorOfUnion(path, errors, options) : formatValidationCommonError(path, NEA.head(errors), options);
    };
    var formatValidationError = function(error, options) {
      return formatValidationCommonError(keyPath(error.context), error, options);
    };
    exports.formatValidationError = formatValidationError;
    var formatValidationErrors = function(errors, options) {
      return pipeable_1.pipe(errors, groupByKey, R.mapWithIndex(function(path, errors2) {
        return format(path, errors2, options);
      }), R.compact, R.toArray, A.map(function(_a) {
        var _key = _a[0], error = _a[1];
        return error;
      }));
    };
    exports.formatValidationErrors = formatValidationErrors;
    var reporter = function(validation, options) {
      return pipeable_1.pipe(validation, E.mapLeft(function(errors) {
        return exports.formatValidationErrors(errors, options);
      }), E.fold(function(errors) {
        return errors;
      }, function() {
        return [];
      }));
    };
    exports.reporter = reporter;
    var prettyReporter = { report: exports.reporter };
    exports.default = prettyReporter;
  }
});

// node_modules/ton/dist/client/api/TonCache.js
var require_TonCache = __commonJS({
  "node_modules/ton/dist/client/api/TonCache.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryCache = void 0;
    var InMemoryCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
        this.set = async (namespace, key, value) => {
          if (value !== null) {
            this.cache.set(namespace + "$$" + key, value);
          } else {
            this.cache.delete(namespace + "$$" + key);
          }
        };
        this.get = async (namespace, key) => {
          let res = this.cache.get(namespace + "$$" + key);
          if (res !== void 0) {
            return res;
          } else {
            return null;
          }
        };
      }
    };
    exports.InMemoryCache = InMemoryCache;
  }
});

// node_modules/dataloader/index.js
var require_dataloader = __commonJS({
  "node_modules/dataloader/index.js"(exports, module) {
    "use strict";
    init_shim();
    var DataLoader = function() {
      function DataLoader2(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
      }
      var _proto = DataLoader2.prototype;
      _proto.load = function load(key) {
        if (key === null || key === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      };
      _proto.loadMany = function loadMany(keys3) {
        if (!isArrayLike(keys3)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys3 + "."));
        }
        var loadPromises = [];
        for (var i = 0; i < keys3.length; i++) {
          loadPromises.push(this.load(keys3[i])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      };
      _proto.clear = function clear(key) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          cacheMap["delete"](cacheKey);
        }
        return this;
      };
      _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      };
      _proto.prime = function prime(key, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      };
      return DataLoader2;
    }();
    var enqueuePostPromiseJob = typeof import_process.default === "object" && typeof import_process.default.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        import_process.default.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise = loader._batchLoadFn(batch.keys);
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i = 0; i < batch.callbacks.length; i++) {
          var value = values[i];
          if (value instanceof Error) {
            batch.callbacks[i].reject(value);
          } else {
            batch.callbacks[i].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i = 0; i < batch.keys.length; i++) {
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
      }
    }
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i = 0; i < batch.cacheHits.length; i++) {
          batch.cacheHits[i]();
        }
      }
    }
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key) {
          return key;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    function isArrayLike(x) {
      return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
    }
    module.exports = DataLoader;
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function bind8(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    init_shim();
    var bind8 = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend8(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind8(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend: extend8,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    init_shim();
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    init_shim();
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match5 ? decodeURIComponent(match5[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    init_shim();
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    init_shim();
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof import_process.default !== "undefined" && Object.prototype.toString.call(import_process.default) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    init_shim();
    module.exports = {
      "version": "0.25.0"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    init_shim();
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i) {
      validators[type2] = function validator(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys3 = Object.keys(options);
      var i = keys3.length;
      while (i-- > 0) {
        var opt = keys3[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain8 = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain8, requestInterceptorChain);
        chain8 = chain8.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain8.length) {
          promise = promise.then(chain8.shift(), chain8.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    init_shim();
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var bind8 = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind8(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    init_shim();
    module.exports = require_axios();
  }
});

// node_modules/ton/package.json
var require_package = __commonJS({
  "node_modules/ton/package.json"(exports, module) {
    module.exports = {
      name: "ton",
      version: "13.3.0",
      repository: "https://github.com/tonwhales/ton.git",
      author: "Steve Korshakov <steve@korshakov.com>",
      license: "MIT",
      main: "dist/index.js",
      files: [
        "dist"
      ],
      scripts: {
        build: "rm -fr dist && tsc --declaration",
        test: "jest --verbose --runInBand",
        release: "yarn build && yarn release-it --npm.yarn1"
      },
      devDependencies: {
        "@release-it/keep-a-changelog": "^3.1.0",
        "@types/jest": "^27.0.1",
        "@types/node": "^16.7.10",
        buffer: "^6.0.3",
        expect: "^27.1.0",
        jest: "^27.1.0",
        "jest-mock": "^27.1.0",
        karma: "^6.3.4",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        "karma-typescript": "^5.5.2",
        "karma-webpack": "^5.0.0",
        prando: "^6.0.1",
        "release-it": "^15.5.1",
        "ton-core": "^0.32.0",
        "ton-crypto": "3.2.0",
        "ts-jest": "^27.0.5",
        "ts-loader": "^9.2.5",
        "ts-node": "^10.7.0",
        typescript: "^4.4.2",
        webpack: "^5.51.2"
      },
      dependencies: {
        axios: "^0.25.0",
        dataloader: "^2.0.0",
        "fp-ts": "^2.11.1",
        "io-ts": "^2.2.16",
        "io-ts-reporters": "^2.0.0",
        "symbol.inspect": "1.0.1",
        teslabot: "^1.3.0"
      },
      peerDependencies: {
        "ton-core": ">=0.32.0",
        "ton-crypto": ">=3.2.0"
      },
      publishConfig: {
        access: "public",
        registry: "https://registry.npmjs.org/"
      },
      "release-it": {
        github: {
          release: true
        },
        plugins: {
          "@release-it/keep-a-changelog": {
            filename: "CHANGELOG.md"
          }
        }
      }
    };
  }
});

// node_modules/ton/dist/client/api/HttpApi.js
var require_HttpApi = __commonJS({
  "node_modules/ton/dist/client/api/HttpApi.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpApi = void 0;
    var t = __importStar((init_es6(), __toCommonJS(es6_exports)));
    var Either_1 = require_Either();
    var io_ts_reporters_1 = __importDefault(require_src());
    var TonCache_1 = require_TonCache();
    var dataloader_1 = __importDefault(require_dataloader());
    var axios_1 = __importDefault(require_axios2());
    var version = require_package().version;
    var blockIdExt = t.type({
      "@type": t.literal("ton.blockIdExt"),
      workchain: t.number,
      shard: t.string,
      seqno: t.number,
      root_hash: t.string,
      file_hash: t.string
    });
    var addressInformation = t.type({
      balance: t.union([t.number, t.string]),
      state: t.union([t.literal("active"), t.literal("uninitialized"), t.literal("frozen")]),
      data: t.string,
      code: t.string,
      last_transaction_id: t.type({
        "@type": t.literal("internal.transactionId"),
        lt: t.string,
        hash: t.string
      }),
      block_id: blockIdExt,
      sync_utime: t.number
    });
    var bocResponse = t.type({
      "@type": t.literal("ok")
    });
    var feeResponse = t.type({
      "@type": t.literal("query.fees"),
      source_fees: t.type({
        "@type": t.literal("fees"),
        in_fwd_fee: t.number,
        storage_fee: t.number,
        gas_fee: t.number,
        fwd_fee: t.number
      })
    });
    var callGetMethod = t.type({
      gas_used: t.number,
      exit_code: t.number,
      stack: t.array(t.unknown)
    });
    var messageData = t.union([
      t.type({
        "@type": t.literal("msg.dataRaw"),
        "body": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataText"),
        "text": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataDecryptedText"),
        "text": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataEncryptedText"),
        "text": t.string
      })
    ]);
    var message = t.type({
      source: t.string,
      destination: t.string,
      value: t.string,
      fwd_fee: t.string,
      ihr_fee: t.string,
      created_lt: t.string,
      body_hash: t.string,
      msg_data: messageData
    });
    var transaction = t.type({
      data: t.string,
      utime: t.number,
      transaction_id: t.type({
        lt: t.string,
        hash: t.string
      }),
      fee: t.string,
      storage_fee: t.string,
      other_fee: t.string,
      in_msg: t.union([t.undefined, message]),
      out_msgs: t.array(message)
    });
    var getTransactions = t.array(transaction);
    var getMasterchain = t.type({
      state_root_hash: t.string,
      last: blockIdExt,
      init: blockIdExt
    });
    var getShards = t.type({
      shards: t.array(blockIdExt)
    });
    var blockShortTxt = t.type({
      "@type": t.literal("blocks.shortTxId"),
      mode: t.number,
      account: t.string,
      lt: t.string,
      hash: t.string
    });
    var getBlockTransactions = t.type({
      id: blockIdExt,
      req_count: t.number,
      incomplete: t.boolean,
      transactions: t.array(blockShortTxt)
    });
    var TypedCache = class {
      constructor(namespace, cache, codec, keyEncoder) {
        this.namespace = namespace;
        this.cache = cache;
        this.codec = codec;
        this.keyEncoder = keyEncoder;
      }
      async get(key) {
        let ex = await this.cache.get(this.namespace, this.keyEncoder(key));
        if (ex) {
          let decoded = this.codec.decode(JSON.parse(ex));
          if ((0, Either_1.isRight)(decoded)) {
            return decoded.right;
          }
        }
        return null;
      }
      async set(key, value) {
        if (value !== null) {
          await this.cache.set(this.namespace, this.keyEncoder(key), JSON.stringify(value));
        } else {
          await this.cache.set(this.namespace, this.keyEncoder(key), null);
        }
      }
    };
    var HttpApi = class {
      constructor(endpoint, parameters) {
        this.endpoint = endpoint;
        this.cache = new TonCache_1.InMemoryCache();
        this.parameters = {
          timeout: (parameters == null ? void 0 : parameters.timeout) || 3e4,
          apiKey: parameters == null ? void 0 : parameters.apiKey
        };
        this.shardCache = new TypedCache("ton-shard", this.cache, t.array(blockIdExt), (src) => src + "");
        this.shardLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = (await this.doCall("shards", { seqno: v }, getShards)).shards;
            await this.shardCache.set(v, loaded);
            return loaded;
          }));
        });
        this.shardTransactionsCache = new TypedCache("ton-shard-tx", this.cache, getBlockTransactions, (src) => src.workchain + ":" + src.shard + ":" + src.seqno);
        this.shardTransactionsLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardTransactionsCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = await this.doCall("getBlockTransactions", { workchain: v.workchain, seqno: v.seqno, shard: v.shard }, getBlockTransactions);
            await this.shardTransactionsCache.set(v, loaded);
            return loaded;
          }));
        }, { cacheKeyFn: (src) => src.workchain + ":" + src.shard + ":" + src.seqno });
      }
      getAddressInformation(address) {
        return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
      }
      async getTransactions(address, opts) {
        const inclusive = opts.inclusive;
        delete opts.inclusive;
        let hash = void 0;
        if (opts.hash) {
          hash = import_buffer.Buffer.from(opts.hash, "base64").toString("hex");
        }
        let limit = opts.limit;
        if (opts.hash && opts.lt && inclusive !== true) {
          limit++;
        }
        let res = await this.doCall("getTransactions", { address: address.toString(), ...opts, limit, hash }, getTransactions);
        if (res.length > limit) {
          res = res.slice(0, limit);
        }
        if (opts.hash && opts.lt && inclusive !== true) {
          res.shift();
          return res;
        } else {
          return res;
        }
      }
      async getMasterchainInfo() {
        return await this.doCall("getMasterchainInfo", {}, getMasterchain);
      }
      async getShards(seqno) {
        return await this.shardLoader.load(seqno);
      }
      async getBlockTransactions(workchain, seqno, shard) {
        return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
      }
      async getTransaction(address, lt, hash) {
        let convHash = import_buffer.Buffer.from(hash, "base64").toString("hex");
        let res = await this.doCall("getTransactions", { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
        let ex = res.find((v) => v.transaction_id.lt === lt && v.transaction_id.hash === hash);
        if (ex) {
          return ex;
        } else {
          return null;
        }
      }
      async callGetMethod(address, method, stack) {
        return await this.doCall("runGetMethod", { address: address.toString(), method, stack: serializeStack(stack) }, callGetMethod);
      }
      async sendBoc(body) {
        await this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
      }
      async estimateFee(address, args) {
        return await this.doCall("estimateFee", {
          address: address.toString(),
          body: args.body.toBoc().toString("base64"),
          "init_data": args.initData ? args.initData.toBoc().toString("base64") : "",
          "init_code": args.initCode ? args.initCode.toBoc().toString("base64") : "",
          ignore_chksig: args.ignoreSignature
        }, feeResponse);
      }
      async doCall(method, body, codec) {
        let headers = {
          "Content-Type": "application/json",
          "X-Ton-Client-Version": version
        };
        if (this.parameters.apiKey) {
          headers["X-API-Key"] = this.parameters.apiKey;
        }
        let res = await axios_1.default.post(this.endpoint, JSON.stringify({
          id: "1",
          jsonrpc: "2.0",
          method,
          params: body
        }), {
          headers,
          timeout: this.parameters.timeout
        });
        if (res.status !== 200 || !res.data.ok) {
          throw Error("Received error: " + JSON.stringify(res.data));
        }
        let decoded = codec.decode(res.data.result);
        if ((0, Either_1.isRight)(decoded)) {
          return decoded.right;
        } else {
          throw Error("Malformed response: " + io_ts_reporters_1.default.report(decoded).join(", "));
        }
      }
    };
    exports.HttpApi = HttpApi;
    function serializeStack(src) {
      let stack = [];
      for (let s of src) {
        if (s.type === "int") {
          stack.push(["num", s.value.toString()]);
        } else if (s.type === "cell") {
          stack.push(["tvm.Cell", s.cell.toBoc().toString("base64")]);
        } else if (s.type === "slice") {
          stack.push(["tvm.Slice", s.cell.toBoc().toString("base64")]);
        } else if (s.type === "builder") {
          stack.push(["tvm.Builder", s.cell.toBoc().toString("base64")]);
        } else {
          throw Error("Unsupported stack item type: " + s.type);
        }
      }
      return stack;
    }
  }
});

// node_modules/ton/dist/client/TonClient.js
var require_TonClient = __commonJS({
  "node_modules/ton/dist/client/TonClient.js"(exports) {
    "use strict";
    init_shim();
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _TonClient_api;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient = void 0;
    var HttpApi_1 = require_HttpApi();
    var ton_core_1 = require_dist2();
    var TonClient = class {
      constructor(parameters) {
        _TonClient_api.set(this, void 0);
        this.parameters = {
          endpoint: parameters.endpoint
        };
        __classPrivateFieldSet(this, _TonClient_api, new HttpApi_1.HttpApi(this.parameters.endpoint, {
          timeout: parameters.timeout,
          apiKey: parameters.apiKey,
          adapter: parameters.httpAdapter
        }), "f");
      }
      /**
       * Get Address Balance
       * @param address address for balance check
       * @returns balance
       */
      async getBalance(address) {
        return (await this.getContractState(address)).balance;
      }
      /**
       * Invoke get method
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
       */
      async callGetMethod(address, name, stack = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, stack);
        if (res.exit_code !== 0) {
          throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
        }
        return { gas_used: res.gas_used, stack: parseStack(res.stack) };
      }
      /**
       * Invoke get method that returns error code instead of throwing error
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
      */
      async callGetMethodWithError(address, name, params = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
        return { gas_used: res.gas_used, stack: parseStack(res.stack), exit_code: res.exit_code };
      }
      /**
       * Get transactions
       * @param address address
       */
      async getTransactions(address, opts) {
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransactions(address, opts);
        let res = [];
        for (let r of tx) {
          res.push((0, ton_core_1.loadTransaction)(ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(r.data, "base64"))[0].beginParse()));
        }
        return res;
      }
      /**
       * Get transaction by it's id
       * @param address address
       * @param lt logical time
       * @param hash transaction hash
       * @returns transaction or null if not exist
       */
      async getTransaction(address, lt, hash) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransaction(address, lt, hash);
        if (res) {
          return (0, ton_core_1.loadTransaction)(ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(res.data, "base64"))[0].beginParse());
        } else {
          return null;
        }
      }
      /**
       * Fetch latest masterchain info
       * @returns masterchain info
       */
      async getMasterchainInfo() {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getMasterchainInfo();
        return {
          workchain: r.init.workchain,
          shard: r.last.shard,
          initSeqno: r.init.seqno,
          latestSeqno: r.last.seqno
        };
      }
      /**
       * Fetch latest workchain shards
       * @param seqno masterchain seqno
       */
      async getWorkchainShards(seqno) {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getShards(seqno);
        return r.map((m) => ({
          workchain: m.workchain,
          shard: m.shard,
          seqno: m.seqno
        }));
      }
      /**
       * Fetch transactions inf shards
       * @param workchain
       * @param seqno
       * @param shard
       */
      async getShardTransactions(workchain, seqno, shard) {
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getBlockTransactions(workchain, seqno, shard);
        if (tx.incomplete) {
          throw Error("Unsupported");
        }
        return tx.transactions.map((v) => ({
          account: ton_core_1.Address.parseRaw(v.account),
          lt: v.lt,
          hash: v.hash
        }));
      }
      /**
       * Send message to a network
       * @param src source message
       */
      async sendMessage(src) {
        const boc = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(src)).endCell().toBoc();
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(boc);
      }
      /**
       * Send file to a network
       * @param src source file
       */
      async sendFile(src) {
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(src);
      }
      /**
       * Estimate fees for external message
       * @param address target address
       * @returns
       */
      async estimateExternalMessageFee(address, args) {
        return await __classPrivateFieldGet(this, _TonClient_api, "f").estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
      }
      /**
       * Send external message to contract
       * @param contract contract to send message
       * @param src message body
       */
      async sendExternalMessage(contract, src) {
        if (await this.isContractDeployed(contract.address) || !contract.init) {
          const message = (0, ton_core_1.external)({
            to: contract.address,
            body: src
          });
          await this.sendMessage(message);
        } else {
          const message = (0, ton_core_1.external)({
            to: contract.address,
            init: { code: contract.init.code, data: contract.init.data },
            body: src
          });
          await this.sendMessage(message);
        }
      }
      /**
       * Check if contract is deployed
       * @param address addres to check
       * @returns true if contract is in active state
       */
      async isContractDeployed(address) {
        return (await this.getContractState(address)).state === "active";
      }
      /**
       * Resolves contract state
       * @param address contract address
       */
      async getContractState(address) {
        let info = await __classPrivateFieldGet(this, _TonClient_api, "f").getAddressInformation(address);
        let balance = BigInt(info.balance);
        let state = info.state;
        return {
          balance,
          state,
          code: info.code !== "" ? import_buffer.Buffer.from(info.code, "base64") : null,
          data: info.data !== "" ? import_buffer.Buffer.from(info.data, "base64") : null,
          lastTransaction: info.last_transaction_id.lt !== "0" ? {
            lt: info.last_transaction_id.lt,
            hash: info.last_transaction_id.hash
          } : null,
          blockId: {
            workchain: info.block_id.workchain,
            shard: info.block_id.shard,
            seqno: info.block_id.seqno
          },
          timestampt: info.sync_utime
        };
      }
      /**
       * Open contract
       * @param src source contract
       * @returns contract
       */
      open(src) {
        return (0, ton_core_1.openContract)(src, (args) => createProvider(this, args.address, args.init));
      }
      /**
       * Create a provider
       * @param address address
       * @param init optional init
       * @returns provider
       */
      provider(address, init4) {
        return createProvider(this, address, init4);
      }
    };
    exports.TonClient = TonClient;
    _TonClient_api = /* @__PURE__ */ new WeakMap();
    function parseStack(src) {
      let stack = [];
      for (let s of src) {
        if (s[0] === "num") {
          let val = s[1];
          if (val.startsWith("-")) {
            stack.push({ type: "int", value: -BigInt(val.slice(1)) });
          } else {
            stack.push({ type: "int", value: BigInt(val) });
          }
        } else if (s[0] === "null") {
          stack.push({ type: "null" });
        } else if (s[0] === "cell") {
          stack.push({ type: "cell", cell: ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(s[1].bytes, "base64"))[0] });
        } else if (s[0] === "slice") {
          stack.push({ type: "slice", cell: ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(s[1].bytes, "base64"))[0] });
        } else if (s[0] === "builder") {
          stack.push({ type: "builder", cell: ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(s[1].bytes, "base64"))[0] });
        } else {
          throw Error("Unsupported stack item type: " + s[0]);
        }
      }
      return new ton_core_1.TupleReader(stack);
    }
    function createProvider(client, address, init4) {
      return {
        async getState() {
          let state = await client.getContractState(address);
          let balance = state.balance;
          let last6 = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: import_buffer.Buffer.from(state.lastTransaction.hash, "base64") } : null;
          let storage;
          if (state.state === "active") {
            storage = {
              type: "active",
              code: state.code ? state.code : null,
              data: state.data ? state.data : null
            };
          } else if (state.state === "uninitialized") {
            storage = {
              type: "uninit"
            };
          } else if (state.state === "frozen") {
            storage = {
              type: "frozen",
              stateHash: import_buffer.Buffer.alloc(0)
            };
          } else {
            throw Error("Unsupported state");
          }
          return {
            balance,
            last: last6,
            state: storage
          };
        },
        async get(name, args) {
          let method = await client.callGetMethod(address, name, args);
          return { stack: method.stack };
        },
        async external(message) {
          let neededInit = null;
          if (init4 && !await client.isContractDeployed(address)) {
            neededInit = init4;
          }
          const ext = (0, ton_core_1.external)({
            to: address,
            init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
            body: message
          });
          let boc = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(ext)).endCell().toBoc();
          await client.sendFile(boc);
        },
        async internal(via, message) {
          let neededInit = null;
          if (init4 && !await client.isContractDeployed(address)) {
            neededInit = init4;
          }
          let bounce = true;
          if (message.bounce !== null && message.bounce !== void 0) {
            bounce = message.bounce;
          }
          let value;
          if (typeof message.value === "string") {
            value = (0, ton_core_1.toNano)(message.value);
          } else {
            value = message.value;
          }
          let body = null;
          if (typeof message.body === "string") {
            body = (0, ton_core_1.comment)(message.body);
          } else if (message.body) {
            body = message.body;
          }
          await via.send({
            to: address,
            value,
            bounce,
            sendMode: message.sendMode,
            init: neededInit,
            body
          });
        }
      };
    }
  }
});

// node_modules/ton/dist/utils/toUrlSafe.js
var require_toUrlSafe = __commonJS({
  "node_modules/ton/dist/utils/toUrlSafe.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUrlSafe = void 0;
    function toUrlSafe(src) {
      while (src.indexOf("/") >= 0) {
        src = src.replace("/", "_");
      }
      while (src.indexOf("+") >= 0) {
        src = src.replace("+", "-");
      }
      while (src.indexOf("=") >= 0) {
        src = src.replace("=", "");
      }
      return src;
    }
    exports.toUrlSafe = toUrlSafe;
  }
});

// node_modules/ton/dist/client/TonClient4.js
var require_TonClient4 = __commonJS({
  "node_modules/ton/dist/client/TonClient4.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _TonClient4_endpoint;
    var _TonClient4_timeout;
    var _TonClient4_adapter;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient4 = void 0;
    var axios_1 = __importDefault(require_axios2());
    var t = __importStar((init_es6(), __toCommonJS(es6_exports)));
    var ton_core_1 = require_dist2();
    var toUrlSafe_1 = require_toUrlSafe();
    var TonClient4 = class {
      constructor(args) {
        _TonClient4_endpoint.set(this, void 0);
        _TonClient4_timeout.set(this, void 0);
        _TonClient4_adapter.set(this, void 0);
        __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
        __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
        __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
      }
      /**
       * Get Last Block
       * @returns last block info
       */
      async getLastBlock() {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!lastBlockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Get block info
       * @param seqno block sequence number
       * @returns block info
       */
      async getBlock(seqno) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!blockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        if (!res.data.exist) {
          throw Error("Block is out of scope");
        }
        return res.data.block;
      }
      /**
       * Get block info by unix timestamp
       * @param ts unix timestamp
       * @returns block info
       */
      async getBlockByUtime(ts) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!blockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        if (!res.data.exist) {
          throw Error("Block is out of scope");
        }
        return res.data.block;
      }
      /**
       * Get block info by unix timestamp
       * @param seqno block sequence number
       * @param address account address
       * @returns account info
       */
      async getAccount(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!accountCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Get account lite info (without code and data)
       * @param seqno block sequence number
       * @param address account address
       * @returns account lite info
       */
      async getAccountLite(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!accountLiteCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Check if account was updated since
       * @param seqno block sequence number
       * @param address account address
       * @param lt account last transaction lt
       * @returns account change info
       */
      async isAccountChanged(seqno, address, lt) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!changedCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Load one unparsed account transaction
       * @param seqno block sequence number
       * @param address account address
       * @param lt account last transaction lt
       * @returns one unparsed transaction
       */
      async getTransaction(seqno, address, lt) {
        const urladdr = address.toString({ urlSafe: true });
        const urlpath = `/block/${seqno}/${urladdr}/tx/${lt.toString(10)}`;
        const res = await axios_1.default.get(new URL(urlpath, __classPrivateFieldGet(this, _TonClient4_endpoint, "f")).href, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!transactionCodec.is(res.data))
          throw Error("Mailformed response");
        const txcell = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(res.data.boc, "base64"))[0];
        return { tx: (0, ton_core_1.loadTransaction)(txcell.beginParse()), ...res.data };
      }
      /**
       * Load unparsed account transactions
       * @param address address
       * @param lt last transaction lt
       * @param hash last transaction hash
       * @returns unparsed transactions
       */
      async getAccountTransactions(address, lt, hash) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!transactionsCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        let data = res.data;
        let tx = [];
        let cells = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(data.boc, "base64"));
        for (let i = 0; i < data.blocks.length; i++) {
          tx.push({
            block: data.blocks[i],
            tx: (0, ton_core_1.loadTransaction)(cells[i].beginParse())
          });
        }
        return tx;
      }
      /**
       * Get network config
       * @param seqno block sequence number
       * @param ids optional config ids
       * @returns network config
       */
      async getConfig(seqno, ids) {
        let tail5 = "";
        if (ids && ids.length > 0) {
          tail5 = "/" + [...ids].sort().join(",");
        }
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail5, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!configCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      /**
       * Execute run method
       * @param seqno block sequence number
       * @param address account address
       * @param name method name
       * @param args method arguments
       * @returns method result
       */
      async runMethod(seqno, address, name, args) {
        let tail5 = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, ton_core_1.serializeTuple)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
        let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/run/" + name + tail5;
        let res = await axios_1.default.get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!runMethodCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return {
          exitCode: res.data.exitCode,
          result: res.data.resultRaw ? (0, ton_core_1.parseTuple)(ton_core_1.Cell.fromBoc(import_buffer.Buffer.from(res.data.resultRaw, "base64"))[0]) : [],
          resultRaw: res.data.resultRaw,
          block: res.data.block,
          shardBlock: res.data.shardBlock
        };
      }
      /**
       * Send external message
       * @param message message boc
       * @returns message status
       */
      async sendMessage(message) {
        let res = await axios_1.default.post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!sendCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return { status: res.data.status };
      }
      /**
       * Open smart contract
       * @param contract contract
       * @returns opened contract
       */
      open(contract) {
        return (0, ton_core_1.openContract)(contract, (args) => createProvider(this, null, args.address, args.init));
      }
      /**
       * Open smart contract
       * @param block block number
       * @param contract contract
       * @returns opened contract
       */
      openAt(block, contract) {
        return (0, ton_core_1.openContract)(contract, (args) => createProvider(this, block, args.address, args.init));
      }
      /**
       * Create provider
       * @param address address
       * @param init optional init data
       * @returns provider
       */
      provider(address, init4) {
        return createProvider(this, null, address, init4 ? init4 : null);
      }
      /**
       * Create provider at specified block number
       * @param block block number
       * @param address address
       * @param init optional init data
       * @returns provider
       */
      providerAt(block, address, init4) {
        return createProvider(this, block, address, init4 ? init4 : null);
      }
    };
    exports.TonClient4 = TonClient4;
    _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap();
    function createProvider(client, block, address, init4) {
      return {
        async getState() {
          let sq = block;
          if (sq === null) {
            let res = await client.getLastBlock();
            sq = res.last.seqno;
          }
          let state = await client.getAccount(sq, address);
          let last6 = state.account.last ? { lt: BigInt(state.account.last.lt), hash: import_buffer.Buffer.from(state.account.last.hash, "base64") } : null;
          let storage;
          if (state.account.state.type === "active") {
            storage = {
              type: "active",
              code: state.account.state.code ? import_buffer.Buffer.from(state.account.state.code, "base64") : null,
              data: state.account.state.data ? import_buffer.Buffer.from(state.account.state.data, "base64") : null
            };
          } else if (state.account.state.type === "uninit") {
            storage = {
              type: "uninit"
            };
          } else if (state.account.state.type === "frozen") {
            storage = {
              type: "frozen",
              stateHash: import_buffer.Buffer.from(state.account.state.stateHash, "base64")
            };
          } else {
            throw Error("Unsupported state");
          }
          return {
            balance: BigInt(state.account.balance.coins),
            last: last6,
            state: storage
          };
        },
        async get(name, args) {
          let sq = block;
          if (sq === null) {
            let res = await client.getLastBlock();
            sq = res.last.seqno;
          }
          let method = await client.runMethod(sq, address, name, args);
          if (method.exitCode !== 0 && method.exitCode !== 1) {
            throw Error("Exit code: " + method.exitCode);
          }
          return {
            stack: new ton_core_1.TupleReader(method.result)
          };
        },
        async external(message) {
          let last6 = await client.getLastBlock();
          let neededInit = null;
          if (init4 && (await client.getAccountLite(last6.last.seqno, address)).account.state.type !== "active") {
            neededInit = init4;
          }
          const ext = (0, ton_core_1.external)({
            to: address,
            init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
            body: message
          });
          let pkg = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(ext)).endCell().toBoc();
          await client.sendMessage(pkg);
        },
        async internal(via, message) {
          let last6 = await client.getLastBlock();
          let neededInit = null;
          if (init4 && (await client.getAccountLite(last6.last.seqno, address)).account.state.type !== "active") {
            neededInit = init4;
          }
          let bounce = true;
          if (message.bounce !== null && message.bounce !== void 0) {
            bounce = message.bounce;
          }
          let value;
          if (typeof message.value === "string") {
            value = (0, ton_core_1.toNano)(message.value);
          } else {
            value = message.value;
          }
          let body = null;
          if (typeof message.body === "string") {
            body = (0, ton_core_1.comment)(message.body);
          } else if (message.body) {
            body = message.body;
          }
          await via.send({
            to: address,
            value,
            bounce,
            sendMode: message.sendMode,
            init: neededInit,
            body
          });
        }
      };
    }
    var lastBlockCodec = t.type({
      last: t.type({
        seqno: t.number,
        shard: t.string,
        workchain: t.number,
        fileHash: t.string,
        rootHash: t.string
      }),
      init: t.type({
        fileHash: t.string,
        rootHash: t.string
      }),
      stateRootHash: t.string,
      now: t.number
    });
    var blockCodec = t.union([t.type({
      exist: t.literal(false)
    }), t.type({
      exist: t.literal(true),
      block: t.type({
        shards: t.array(t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string,
          transactions: t.array(t.type({
            account: t.string,
            hash: t.string,
            lt: t.string
          }))
        }))
      })
    })]);
    var storageStatCodec = t.type({
      lastPaid: t.number,
      duePayment: t.union([t.null, t.string]),
      used: t.type({
        bits: t.number,
        cells: t.number,
        publicCells: t.number
      })
    });
    var accountCodec = t.type({
      account: t.type({
        state: t.union([
          t.type({ type: t.literal("uninit") }),
          t.type({ type: t.literal("active"), code: t.union([t.string, t.null]), data: t.union([t.string, t.null]) }),
          t.type({ type: t.literal("frozen"), stateHash: t.string })
        ]),
        balance: t.type({
          coins: t.string
        }),
        last: t.union([
          t.null,
          t.type({
            lt: t.string,
            hash: t.string
          })
        ]),
        storageStat: t.union([t.null, storageStatCodec])
      }),
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var accountLiteCodec = t.type({
      account: t.type({
        state: t.union([
          t.type({ type: t.literal("uninit") }),
          t.type({ type: t.literal("active"), codeHash: t.string, dataHash: t.string }),
          t.type({ type: t.literal("frozen"), stateHash: t.string })
        ]),
        balance: t.type({
          coins: t.string
        }),
        last: t.union([
          t.null,
          t.type({
            lt: t.string,
            hash: t.string
          })
        ]),
        storageStat: t.union([t.null, storageStatCodec])
      })
    });
    var changedCodec = t.type({
      changed: t.boolean,
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var runMethodCodec = t.type({
      exitCode: t.number,
      resultRaw: t.union([t.string, t.null]),
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      }),
      shardBlock: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var configCodec = t.type({
      config: t.type({
        cell: t.string,
        address: t.string,
        globalBalance: t.type({
          coins: t.string
        })
      })
    });
    var sendCodec = t.type({
      status: t.number
    });
    var transactionsCodec = t.type({
      blocks: t.array(t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })),
      boc: t.string
    });
    var transactionCodec = t.type({
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string
      }),
      boc: t.string,
      proof: t.string
    });
  }
});

// node_modules/ton/dist/wallets/signing/createWalletTransfer.js
var require_createWalletTransfer = __commonJS({
  "node_modules/ton/dist/wallets/signing/createWalletTransfer.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletTransferV4 = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = void 0;
    var ton_core_1 = require_dist2();
    var ton_crypto_1 = require_dist();
    function createWalletTransferV1(args) {
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.seqno, 32);
      if (args.message) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(args.message)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV1 = createWalletTransferV1;
    function createWalletTransferV2(args) {
      if (args.messages.length > 4) {
        throw new Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.seqno, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV2 = createWalletTransferV2;
    function createWalletTransferV3(args) {
      if (args.messages.length > 4) {
        throw new Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.walletId, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      signingMessage.storeUint(args.seqno, 32);
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV3 = createWalletTransferV3;
    function createWalletTransferV4(args) {
      if (args.messages.length > 4) {
        throw new Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.walletId, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      signingMessage.storeUint(args.seqno, 32);
      signingMessage.storeUint(0, 8);
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV4 = createWalletTransferV4;
  }
});

// node_modules/ton/dist/wallets/WalletContractV1R1.js
var require_WalletContractV1R1 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV1R1.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R1 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R1 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV1R1(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          return ton_core_1.Cell.fromBoc(state.state.data)[0].beginParse().loadUint(32);
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R1 = WalletContractV1R1;
  }
});

// node_modules/ton/dist/wallets/WalletContractV1R2.js
var require_WalletContractV1R2 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV1R2.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R2 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R2 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV1R2(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R2 = WalletContractV1R2;
  }
});

// node_modules/ton/dist/wallets/WalletContractV1R3.js
var require_WalletContractV1R3 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV1R3.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R3 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R3 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV1R3(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(executor, message) {
        await executor.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R3 = WalletContractV1R3;
  }
});

// node_modules/ton/dist/wallets/WalletContractV2R1.js
var require_WalletContractV2R1 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV2R1.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV2R1 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV2R1 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV2R1(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV2)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV2R1 = WalletContractV2R1;
  }
});

// node_modules/ton/dist/wallets/WalletContractV2R2.js
var require_WalletContractV2R2 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV2R2.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV2R2 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV2R2 = class {
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV2R2(args.workchain, args.publicKey);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV2)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV2R2 = WalletContractV2R2;
  }
});

// node_modules/ton/dist/wallets/WalletContractV3R1.js
var require_WalletContractV3R1 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV3R1.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV3R1 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV3R1 = class {
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV3R1(args.workchain, args.publicKey, args.walletId);
      }
      /**
       * Get wallet balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV3)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV3R1 = WalletContractV3R1;
  }
});

// node_modules/ton/dist/wallets/WalletContractV3R2.js
var require_WalletContractV3R2 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV3R2.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV3R2 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV3R2 = class {
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV3R2(args.workchain, args.publicKey, args.walletId);
      }
      /**
       * Get wallet balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV3)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV3R2 = WalletContractV3R2;
  }
});

// node_modules/ton/dist/wallets/WalletContractV4.js
var require_WalletContractV4 = __commonJS({
  "node_modules/ton/dist/wallets/WalletContractV4.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV4 = void 0;
    var ton_core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV4 = class {
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = ton_core_1.Cell.fromBoc(import_buffer.Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
        let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
        this.init = { code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
      }
      static create(args) {
        return new WalletContractV4(args.workchain, args.publicKey, args.walletId);
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV4)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, ton_core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV4 = WalletContractV4;
  }
});

// node_modules/ton/dist/jetton/JettonMaster.js
var require_JettonMaster = __commonJS({
  "node_modules/ton/dist/jetton/JettonMaster.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonMaster = void 0;
    var ton_core_1 = require_dist2();
    var JettonMaster = class {
      constructor(address) {
        this.address = address;
      }
      static create(address) {
        return new JettonMaster(address);
      }
      async getWalletAddress(provider, owner) {
        let res = await provider.get("get_wallet_address", [{ type: "slice", cell: (0, ton_core_1.beginCell)().storeAddress(owner).endCell() }]);
        return res.stack.readAddress();
      }
      async getJettonData(provider) {
        let res = await provider.get("get_jetton_data", []);
        let totalSupply = res.stack.readBigNumber();
        let mintable = res.stack.readBoolean();
        let adminAddress = res.stack.readAddress();
        let content = res.stack.readCell();
        let walletCode = res.stack.readCell();
        return {
          totalSupply,
          mintable,
          adminAddress,
          content,
          walletCode
        };
      }
    };
    exports.JettonMaster = JettonMaster;
  }
});

// node_modules/ton/dist/jetton/JettonWallet.js
var require_JettonWallet = __commonJS({
  "node_modules/ton/dist/jetton/JettonWallet.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonWallet = void 0;
    var JettonWallet = class {
      constructor(address) {
        this.address = address;
      }
      static create(address) {
        return new JettonWallet(address);
      }
      async getBalance(provider) {
        let state = await provider.getState();
        if (state.state.type !== "active") {
          return 0n;
        }
        let res = await provider.get("get_wallet_data", []);
        return res.stack.readBigNumber();
      }
    };
    exports.JettonWallet = JettonWallet;
  }
});

// node_modules/ton/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/ton/dist/index.js"(exports) {
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonWallet = exports.JettonMaster = exports.WalletContractV4 = exports.WalletContractV3R2 = exports.WalletContractV3R1 = exports.WalletContractV2R2 = exports.WalletContractV2R1 = exports.WalletContractV1R3 = exports.WalletContractV1R2 = exports.WalletContractV1R1 = exports.TonClient4 = exports.TonClient = exports.HttpApi = void 0;
    __exportStar(require_dist2(), exports);
    var HttpApi_1 = require_HttpApi();
    Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
      return HttpApi_1.HttpApi;
    } });
    var TonClient_1 = require_TonClient();
    Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
      return TonClient_1.TonClient;
    } });
    var TonClient4_1 = require_TonClient4();
    Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
      return TonClient4_1.TonClient4;
    } });
    var WalletContractV1R1_1 = require_WalletContractV1R1();
    Object.defineProperty(exports, "WalletContractV1R1", { enumerable: true, get: function() {
      return WalletContractV1R1_1.WalletContractV1R1;
    } });
    var WalletContractV1R2_1 = require_WalletContractV1R2();
    Object.defineProperty(exports, "WalletContractV1R2", { enumerable: true, get: function() {
      return WalletContractV1R2_1.WalletContractV1R2;
    } });
    var WalletContractV1R3_1 = require_WalletContractV1R3();
    Object.defineProperty(exports, "WalletContractV1R3", { enumerable: true, get: function() {
      return WalletContractV1R3_1.WalletContractV1R3;
    } });
    var WalletContractV2R1_1 = require_WalletContractV2R1();
    Object.defineProperty(exports, "WalletContractV2R1", { enumerable: true, get: function() {
      return WalletContractV2R1_1.WalletContractV2R1;
    } });
    var WalletContractV2R2_1 = require_WalletContractV2R2();
    Object.defineProperty(exports, "WalletContractV2R2", { enumerable: true, get: function() {
      return WalletContractV2R2_1.WalletContractV2R2;
    } });
    var WalletContractV3R1_1 = require_WalletContractV3R1();
    Object.defineProperty(exports, "WalletContractV3R1", { enumerable: true, get: function() {
      return WalletContractV3R1_1.WalletContractV3R1;
    } });
    var WalletContractV3R2_1 = require_WalletContractV3R2();
    Object.defineProperty(exports, "WalletContractV3R2", { enumerable: true, get: function() {
      return WalletContractV3R2_1.WalletContractV3R2;
    } });
    var WalletContractV4_1 = require_WalletContractV4();
    Object.defineProperty(exports, "WalletContractV4", { enumerable: true, get: function() {
      return WalletContractV4_1.WalletContractV4;
    } });
    var JettonMaster_1 = require_JettonMaster();
    Object.defineProperty(exports, "JettonMaster", { enumerable: true, get: function() {
      return JettonMaster_1.JettonMaster;
    } });
    var JettonWallet_1 = require_JettonWallet();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
  }
});
export default require_dist3();
//# sourceMappingURL=ton.js.map
